{
  "Home": "主页",
  "Download": "下载",
  "Start": "入门",
  "Reference": "参考文献",
  "reference-tagline": "Processing 的直觉乘以 JavaScript 的力量",
  "reference-search": "搜寻 API",
  "reference-menu-home": "主页",
  "reference-menu-download": "下载",
  "reference-menu-get-started": "入门",
  "reference-menu-reference": "参考文献",
  "reference-menu-libraries": "程式库",
  "reference-menu-learn": "学习",
  "reference-menu-examples": "范例",
  "reference-menu-books": "书籍",
  "reference-menu-community": "社群",
  "reference-menu-forum": "论坛",
  "reference-description1": "找不到您要的条目吗？您或许要查看",
  "reference-description2": "或",
  "reference-description3": "You can download an offline version of the reference",
  "reference-description4": "here",
  "reference-contribute1": "发现任何错误或有任何建议吗",
  "reference-contribute2": "请让我们知道",
  "reference-error1": "发现错字或错误吗？",
  "reference-error2": "的文献被记录在",
  "reference-error3": "非常欢迎您",
  "reference-error4": "更改该文件",
  "reference-error5": "并开启一个 pull request。",
  "reference-example": "范例",
  "reference-description": "说明",
  "reference-extends": "继承",
  "reference-parameters": "参数",
  "reference-syntax": "语法",
  "reference-returns": "返回",
  "footer1": "p5.js 的原作者为",
  "footer2": "并在",
  "footer3": "和",
  "footer4": "的支持下由其合作社群所开发。形象及平面设计",
  "Libraries": "程式库",
  "Learn": "学习",
  "Examples": "范例",
  "Books": "书籍",
  "Community": "社群",
  "Contribute": "贡献",
  "Forum": "论坛",
  "h1": "参考文献",
  "Color": "颜色",
  "Shape": "形状",
  "Creating & Reading": "创造及读取",
  "Setting": "设置",
  "2D Primitives": "2D 形状",
  "Attributes": "属性",
  "Curves": "弧形",
  "Vertex": "顶点",
  "3D Models": "3D 模型",
  "3D Primitives": "3D 形状",
  "Constants": "常量",
  "Structure": "结构",
  "Environment": "环境",
  "DOM": "DOM",
  "Rendering": "渲染",
  "Transform": "变形",
  "Data": "资料",
  "Dictionary": "字典",
  "Array Functions": "数组函数",
  "Conversion": "转换",
  "String Functions": "字符串函数",
  "Events": "事件",
  "Acceleration": "加速度",
  "Keyboard": "键盘",
  "Mouse": "滑鼠",
  "Touch": "触动",
  "Image": "图像",
  "Loading & Displaying": "加载和显示",
  "Pixels": "像素",
  "IO": "输入和输出",
  "Input": "输入",
  "Output": "输出",
  "Table": "表格",
  "Time & Date": "时间和日期",
  "XML": "XML",
  "Math": "数学",
  "Calculation": "计算",
  "Noise": "噪声",
  "Trigonometry": "三角学",
  "Typography": "字体",
  "Font": "字形",
  "Lights, Camera": "灯光、相机",
  "Camera": "相机",
  "Lights": "灯光",
  "Material": "材料",
  "p5": {
    "alpha": {
      "description": "从颜色或像素数组中提取透明度（alpha）值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该透明度值"
    },
    "blue": {
      "description": "从颜色或像素数组中提取蓝色彩值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该蓝色彩值"
    },
    "brightness": {
      "description": "从颜色或像素数组中提取 HSB 的亮度值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该亮度值"
    },
    "color": {
      "description": "创造颜色物件并将其存放在颜色变量内。依当时的颜色模式而定，参数可被解读成 RGB 或 HSB 值。默认模式为 RGB 值从 0 至 255，因此调用函数 color(255, 204, 0) 将返回亮黄色。<br><br>请注意如果 color() 值被提供一个参数，它将被解读成灰阶值；增加多一个参数，它将被用来定义透明度。当被提供三个参数时，它们将被解读成 RGB 或 HSB 值；增加第四个参数将定义透明度。<br><br>如果只提供单一字符串参数，RGB、RGBA 和 十六进制 CSS 颜色字符串都为受支持的模式。在这情况下，提供第二个参数以定义透明度值并不被支持，而需使用 RGBA 字符串。",
      "params": ["数字：一个定义白与黑之间的数值",
                 "数字：透明度值，需在被定义的范围内（默认为 0 至 255）",
                 "数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "字符串：颜色字符串",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color："],
      "returns": "p5.Color：返回的颜色"
    },
    "green": {
      "description": "从颜色或像素数组中提取绿色彩值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该绿色彩值"
    },
    "hue": {
      "description": "从颜色或像素数组中提取色调值。<br><br>色调值可在 HSB 及 HSL 颜色中找到。此函数会返回标准化 HSB 值的色调值只要被提供的参数是 HSB 颜色物件（或如果被提供的参数是像素数组，颜色模式是 HSB），不然默认将会返回标准化 HSL 值的色调值。（两者的值只有在这两个不同的系统有不同的最高色调值时才会有差别）",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该色调值"
    },
    "lerpColor": {
      "description": "混合两个颜色以找到一个介于它们之间的颜色。<br><br>amt 参数代表两个值之间插入的量，0.0 代表第一个颜色、0.1 代表非常接近第一个颜色、0.5 代表两个颜色之间的一半等等。低于 0 的值将被当作 0 看待。这和 lerp() 的行为不一样不过这是因为在范围外的值可能产生奇怪和意料之外的颜色。",
      "params": ["p5.Color：从这颜色开始插入",
                 "p5.Color：在这颜色结束插入",
                 "数字：一个介于 0 和 1 的数字"],
      "returns": "p5.Color：插值颜色"
    },
    "lightness": {
      "description": "从颜色或像素数组中提取 HSL 的光度值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该光度值"
    },
    "red": {
      "description": "从颜色或像素数组中提取红色彩值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该红色彩值"
    },
    "saturation": {
      "description": "从颜色或像素数组中提取饱和度值。<br><br>饱和度在 HSB 和 HSL 模式中的缩放比例不同。此函数将会返回 HSB 值的饱和度值只要被提供的参数是 HSB 颜色物件（或如果被提供的参数是像素数组，颜色模式是 HSB），不然默认将会返回 HSL 值的饱和度值。",
      "params": ["p5.Color | 数字数组 | 字符串：p5.Color 物件、颜色部件或 CSS 颜色值"],
      "returns": "数字：该饱和度值"
    },
    "background": {
      "description": "background() 函数设定 p5.js 画布的背景颜色。默认背景颜色为浅灰色。这函数通常用在 draw() 函数内以在各画面开始时清空画布，不过它也能在 setup() 内使用以定义第一个画面的背景颜色或当背景颜色只需要被定义一次时。<br><br>背景颜色可用 RGB、HSB 或 HSL 颜色定义，取决于当时的颜色模式（默认色彩空间是 RGB，而每个数值都介于 0 至 255 之间）。默认透明度值也介于 0 至 255 之间。<br><br>如果所提供的参数是单一字符串，RGB、RGBA 和十六进制 CSS 颜色字符串及所有命名颜色都可以使用。在这情况下，提供第二个参数以定义透明度值并不被支持，而需使用 RGBA 字符串。<br><br>p5.Color 物件也能被用来定义背景颜色。<br><br>p5.Image 也能被用来提供背景图像。",
      "params": ["p5.Color：任何使用 color() 函数创造的颜色",
               "字符串：颜色字符串，可接受的格式包括：整数 rgb() 或 rgba()、百分率 rgb() 或 rgba()、3 位十六进制、6 位十六进制",
               "数字：透明度值，需在被定义的范围内（默认为 0 至 255）",
               "数字：一个定义白与黑之间的数值",
               "数字：红彩值或色调值（取决于当时的颜色模式）",
               "数字：绿彩值或饱和度值（取决于当时的颜色模式）",
               "数字：蓝彩值或亮度值（取决于当时的颜色模式）",
               "数字[]：一个有红、绿、蓝及透明度值的数组",
               "p5.Image：一个使用 loadImage() 或 createImage() 创造的图像，用以设定背景图像（必须和画布有相同的大小）"],
      "returns": ""
    },
    "clear": {
      "description": "清除图形缓冲区内的像素。这函数只能用于使用 createCanvas() 函数创造的 p5.Canvas 物件，而不能用于主要的显示窗口。使用 createGraphics() 创造的图形缓冲并不像主要的图形缓冲，它们能是完全透明或半透明的。这函数将清空所有东西使每个像素都是 100% 透明。",
      "returns": ""
    },
    "colorMode": {
      "description": "colorMode() 改变 p5.js 解读颜色资料的方式。默认情况下，fill()、stroke()、background() 及 color() 的参数都是介于 0 至 255 的 RGB 颜色值。这和设置 colorMode(RGB, 255) 的效果一样。设置 colorMode(HSB) 让您使用 HSB 模式，默认情况下，这代表 colorMode(HSB, 360, 100, 100, 1)。您也可以使用 HSL。",
      "params": ["常量: RGB、HSB 或 HSL，分别代表红绿蓝及色调/饱和度/亮度（或光度）",
                 "数字：所有数值的最大值",
                 "数字：红色值或色调值的最大值，取决于当时的颜色模式",
                 "数字：绿色值或饱和度值的最大值，取决于当时的颜色模式",
                 "数字：蓝色值或亮度/光度值的最大值，取决于当时的颜色模式",
                 "数字：透明度值的最大值"],
                 "returns": ""
    },
    "fill": {
      "description": "设置形状的填充色。比如说，如果您调用 fill(204, 102, 0)，所有接下来的形状都会被填上橙色。这颜色可用 RGB 或 HSB 颜色定义，取决于当时的颜色模式（默认色彩空间是 RGB，而每个数值都介于 0 至 255 之间）。默认透明度值也介于 0 至 255 之间。<br><br>如果所提供的参数是单一字符串，RGB、RGBA 和十六进制 CSS 颜色字符串及所有命名颜色都可以使用。在这情况下，提供第二个参数以定义透明度值并不被支持，而需使用 RGBA 字符串。<br><br>p5.Color 物件也能被用来定义填充颜色。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "数字：",
                 "字符串：颜色字符串",
                 "数字：灰阶值",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color：填充色"],
      "returns": ""
    },
    "noFill": {
      "description": "禁用形状填充。如果 noStroke() 和 noFill() 都被调用的话，没有形状会被画在荧幕上。",
      "returns": ""
    },
    "noStroke": {
      "description": "禁用形状外线。如果 noStroke() 和 noFill() 都被调用的话，没有形状会被画在荧幕上。",
      "returns": ""
    },
    "stroke": {
      "description": "设置形状的外形线色。这颜色可用 RGB 或 HSB 颜色定义，取决于当时的颜色模式（默认色彩空间是 RGB，而每个数值都介于 0 至 255 之间）。默认透明度值也介于 0 至 255 之间。<br><br>如果所提供的参数是单一字符串，RGB、RGBA 和十六进制 CSS 颜色字符串及所有命名颜色都可以使用。在这情况下，提供第二个参数以定义透明度值并不被支持，而需使用 RGBA 字符串。<br><br>p5.Color 物件也能被用来定义外形线颜色。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "数字：",
                 "字符串：颜色字符串",
                 "数字：灰阶值",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color：外形线色"],
      "returns": ""
    },

    "arc": {
      "description": "在荧幕上画个弧形。如果函数调用只提供 x、y、w、h、start 及 stop 参数，弧形将会被画成开放的饼形段。如果提供 mode 参数，弧形可是开放式半圆形（OPEN）、封闭式半圆形（CHORD）或封闭式饼形段（PIE）。原点可使用 ellipseMode() 函数设定。",
      "params": ["数字：弧形的椭圆形的 x 坐标",
                 "数字：弧形的椭圆形的 y 坐标",
                 "数字：弧形的椭圆形的宽度",
                 "数字：弧形的椭圆形的高度",
                 "数字：弧形开始的角度，用弧度定义",
                 "数字：弧形结束的角度，用弧度定义",
                 "常数：可选参数用以定义弧形的画法，可用 CHORD、PIE 或 OPEN"],
      "returns": ""
    },
    "ellipse": {
      "description": "在荧幕上画个椭圆形。宽度和高度相同的椭圆形为正圆形。在默认上，前两个参数将定义位置而第三和第四个参数将定义形状的宽度和高度。如果高度参数没有被提供的话，宽度参数值将为用来定义高度和宽度。如果高度或宽度为负数，函数将会取绝对值。原点可使用 ellipseMode() 函数设定。",
      "params": ["数字：椭圆形的 x 坐标",
                 "数字：椭圆形的 y 坐标",
                 "数字：椭圆形的宽度",
                 "数字：椭圆形的高度",
                 "整数：椭圆形的径向扇区数"],
      "returns": ""
    },
    "line": {
      "description": "在荧幕上画个直线（两点之间的直接路径）。有四个参数的 line() 函数将画个二维直线。如果要将直线上色，可使用 stroke() 函数。直线并不能有填充色，因此 fill() 函数将不会影响直线的颜色。二维直线在默认情况下有一像素的宽度，不过您可以使用 strokeWeight() 函数更改宽度。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第一个点的 z 坐标",
                 "数字：第二个点的 z 坐标"],
      "returns": ""
    },
    "point": {
      "description": "画一个点，一个在空间内一像素的坐标。第一个参数是点的横向值，第二个参数是点的垂直值。点的颜色是由当时的外线色决定。",
      "params": ["数字：x 坐标",
                 "数字：y 坐标",
                 "数字：z 坐标（用于 WEBGL 模式"],
      "returns": ""
    },
    "quad": {
      "description": "画一个四角形。四角形或四边形是个有四个边的多边形。他和方形相似不过四个角并不需要是九十度。前两个参数 （x1、x2）定义第一个点而随后的配对参数应该以顺时或逆时针的方向定义。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第三个点的 x 坐标",
                 "数字：第三个点的 y 坐标",
                 "数字：第四个点的 x 坐标",
                 "数字：第四个点的 y 坐标",
                 "数字：",
                 "数字：",
                 "数字：",
                 "数字："],
      "returns": ""
    },
    "rect": {
      "description": "在荧幕上画个方形。方形是每个角都为九十度的四边形。在默认上，前两个参数将定义位置而第三和第四个参数将定义形状的宽度和高度。这些参数被解读的方式可用 rectMode() 函数改变。<br><br>如果提供第五、六、七及八个参数，将定义左上角、右上角、右下角及左下角的拐角半径。没被定义的拐角半径参数将被定义为参数列内上一个定义的拐角半径值。",
      "params": ["数字：方形的 x 坐标",
                 "数字：方形的 y 坐标",
                 "数字：方形的宽度",
                 "数字：方形的高度",
                 "数字：可选性左上角拐角半径值",
                 "数字：可选性右上角拐角半径值",
                 "数字：可选性右下角拐角半径值",
                 "数字：可选性左下角拐角半径值",
                 "整数：x 方向段数",
                 "整数：y 方向段数"],
      "returns": ""
    },
    "triangle": {
      "description": "三角形是个由连接三个点所形成的平面形。前两个参数定义第一个点，中间两个参数定义第二个点而最后两个参数定义第三个点。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第三个点的 x 坐标",
                 "数字：第三个点的 y 坐标"],
      "returns": ""
    },
    "ellipseMode": {
      "description": "更改 ellipse() 参数被解读的方式，用以更改椭圆形被画在画布上的位置。<br><br>默认模式为 ellipseMode(CENTER)，ellipse() 前两个参数将被解读成椭圆形的中心点，而第三和第四个参数为宽度和高度。<br><br>ellipseMode(RADIUS) 将 ellipse() 的前两个参数解读成形状的中心点，但是第三和第四个参数被用于定义形状的半径宽度和半径高度<br><br>ellipseMode(CORNER) 将 ellipse() 的前两个参数解读成形状左上角的位置，而第三和第四个参数为宽度和高度<br><br>ellipseMode(CORNERS) 将 ellipse() 的前两个参数解读成形状其中一个角落的位置，而第三和第四个参数则被解读成对面角落的位置。<br><br>参数必须全是大写因为 Javascript 是个区分大小写的编程语言。",
      "params": ["常量：CENTER、RADIUS、CORNER 或 CORNERS"],
      "returns": ""
    },
    "noSmooth": {
      "description": "所有形状的边缘都为锯齿状。注意 smooth() 为默认模式所以您必须调用 noSmooth() 以禁用平滑形状、图像及字体。",
      "returns": ""
    },
    "rectMode": {
      "description": "更改 rect() 参数被解读的方式，用以更改方形被画在画布上的位置。<br><br>默认模式为 rectMode(CORNER), rect() 前两个参数将被解读成形状的左上角的位置，而第三和第四个参数为宽度和高度。<br><br>rectMode(CORNERS) 将 rect() 的前两个参数解读成形状其中一个角落的位置，而第三和第四个参数则被解读成对面角落的位置。<br><br>rectMode(CENTER) 将 rect() 的前两个参数解读成形状的中心点，而第三和第四个参数为宽度和高度。<br><br>rectMode(RADIUS) 也将的前两个参数解读成形状的中心点，但第三和第四个参数被用来定义形状一半的宽度和一半的高度。<br><br>参数必须全是大写因为 Javascript 是个区分大小写的编程语言。",
      "params": ["常量：CORNER、CORNERS、CENTER 或 RADIUS"],
      "returns": ""
    },
    "smooth": {
      "description": "所有形状的边缘都为非锯齿（平滑）状。smooth() 也将提高调整过大小的图像的素质。注意 smooth() 为默认模式；noSmooth() 也能用来禁用平滑形状、图像及字体。",
      "returns": ""
    },
    "strokeCap": {
      "description": "定义线条顶点的风格。顶点风格可以是方形、扩展式或圆形，它们个别参数为：SQUARE、PROJECT 及 ROUND。默认模式为 ROUND。",
      "params": ["常量：SQUARE、PROJECT 或 ROUND"],
      "returns": ""
    },
    "strokeJoin": {
      "description": "定义线条连接的风格。这些链接可以是尖角、斜角或圆角，它们个别参数为：MITER、BEVEL 及 ROUND。默认模式为 MITER。",
      "params": ["常量：MITER、BEVEL 或 ROUND"],
      "returns": ""
    },
    "strokeWeight": {
      "description": "定义线条、点及形状边线的宽度（粗度）。所有宽度单位都是像素。",
      "params": ["数字：线条的粗度（像素单位）"],
      "returns": ""
    },
    "bezier": {
      "description": "在荧幕上画个三次贝塞尔曲线。这些曲线是由一系列锚点和控制点所定义的。前两个参数定义第一个锚点而最后两个参数定义另一个锚点，这也是曲线的第一和最后一个点。中间的参数是用来定义控制点的位置并将决定曲线的形状。一般来说，控制点会将曲线“拉”向它们的方向。",
      "params": ["数字：第一个锚点的 x 坐标",
                 "数字：第一个锚点的 y 坐标",
                 "数字：第一个控制点的 x 坐标",
                 "数字：第一个控制点的 y 坐标",
                 "数字：第二个控制点的 x 坐标",
                 "数字：第二个控制点的 y 坐标",
                 "数字：第二个锚点的 x 坐标",
                 "数字：第二个锚点的 y 坐标",
                 "数字：第一个锚点的 z 坐标",
                 "数字：第一个控制点的 z 坐标",
                 "数字：第二个锚点的 z 坐标",
                 "数字：第二个控制点的 z 坐标"],
      "returns": ""
    },
    "bezierDetail": {
      "description": "定义贝塞尔曲线的解析度<br><br>默认值为 20。<br><br>这函数只有在 WEBGL 模式下有效果因为默认画布渲染模式并不会使用这设定。",
      "params": ["数字：曲线的解析度"],
      "returns": ""
    },
    "bezierPoint": {
      "description": "计算在 a、b、c、d 点定义的贝塞尔曲线上 t 位置的坐标。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。这函数可以先调用 x 坐标然后在调用 y 坐标已找到曲线上 t 位置的点坐标。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的值"
    },
    "bezierTangent": {
      "description": "计算在 a、b、c、d 点定义的贝塞尔曲线上 t 位置的切线值。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的切线值"
    },
    "curve": {
      "description": "在荧幕上的两点之间画一个曲线，两点由中间四个参数定义。前两个参数为控制点，可以当作曲线是从这个点开始的虽然它并不会被画出来。最后两个参数同样也是用来定义另外一个控制点。<br><br>更长的曲线能使用一系列 curve() 函数创造或使用 curveVertex()。另外一个叫 curveTightness() 的函数提供曲线视觉质量的控制。curve() 函数使用的是 Catmull-Rom 样条函数。",
      "params": ["数字：起点控制点的 x 坐标",
                 "数字：起点控制点的 y 坐标",
                 "数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：终点控制点的 x 坐标",
                 "数字：终点控制点的 y 坐标",
                 "数字：起点控制点的 z 坐标",
                 "数字：第一个点的 z 坐标",
                 "数字：第二个点的 z 坐标",
                 "数字：终点控制点的 z 坐标"],
      "returns": ""
    },
    "curveDetail": {
      "description": "定义曲线的解析度<br><br>默认值为 20。<br><br>这函数只有在 WEBGL 模式下有效果因为默认画布渲染模式并不会使用这设定。",
      "params": ["数字：曲线的解析度"],
      "returns": ""
    },
    "curveTightness": {
      "description": "更改由 curve() 及 curveVertex() 所创造的曲线的质量。所提供的参数将决定曲线如何切合顶点。0.0 是紧实度的默认值（这值表示曲线为 Catmull-Rom 样条）而 1.0 将使用直线连接所有点。在 -5.0 及 5.0 之间的值会是曲线变形不过他们仍然能被识别而当值越来越大时，曲线也会跟着变形。",
      "params": ["数字：从原顶点的变形量"],
      "returns": ""
    },
    "curvePoint": {
      "description": "计算在 a、b、c、d 点定义的曲线上 t 位置的坐标。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。这函数可以先调用 x 坐标然后在调用 y 坐标已找到曲线上 t 位置的点坐标。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的值"
    },
    "curveTangent": {
      "description": "计算在 a、b、c、d 点定义的曲线上 t 位置的切线值。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的切线值"
    },
    "beginContour": {
      "description": "使用 beginContour() 及 endContour() 函数以在其他形状内创造剪影形状，比如说 “O” 字母内的空间。beginContour() 将开始记录形状的顶点而 endContour() 则停止记录。定义剪影形状的顶点定义的方向（顺时或逆时针）必须和包含它的形状不同。如果外形的顶点是顺时针方向定义的，那么它里面的形状的顶点需是逆时针方向定义。<br><br>这些函数只能在一对 beginShape()/endShape() 函数之间使用而变形函数如 translate()、rotate() 及 scale() 在一对 beginContour()/endContour() 内并不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在里面使用。",
      "returns": ""
    },
    "beginShape": {
      "description": "使用 beginShape() 及 endShape() 函数可让您创造更复杂的形状。beginShape() 将开始记录形状的顶点而 endShape() 则停止记录。所提供的参数将决定由所提供的顶点该画出怎样的形状。如果模式没有被提供，所定义的形状可以是任何不规则的多边形。<br><br>可提供给 beginShape() 的参数包括 POINTS、LINES、TRIANGLES、TRIANGLE_FAN、TRIANGLE_STRIP、QUADS 及 QUAD_STRIP。在调用 beginShape() 函数之后，一系列 vertex() 函数必须接着调用。调用 endShape() 以停止绘制形状。每个形状都将会有由当时外线色所定义的外线色及当时的填充色。<br><br>变形函数如 translate()、rotate() 及 scale() 在 beginShape() 内不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在beginShape()里面使用。",
      "params": ["常量：POINTS、LINES、TRIANGLES、TRIANGLE_FAN、TRIANGLE_STRIP、QUADS 或 QUAD_STRIP"],
      "returns": ""
    },
    "bezierVertex": {
      "description": "定义贝塞尔曲线的顶点坐标。每次调用 bezierVertex() 将定义贝塞尔曲线的两个控制点和一个锚点，以在线或形状上增加一个新部分。<br><br>在 beginShape() 内第一次调用 bezierVertex() 之前必须先调用一次 vertex() 以定义第一个锚点。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。",
      "params": ["数字：第一个控制点的 x 坐标",
                 "数字：第一个控制点的 y 坐标",
                 "数字：第二个控制点的 x 坐标",
                 "数字：第二个控制点的 y 坐标",
                 "数字：第一个锚点的 x 坐标",
                 "数字：第二个锚点的 x 坐标"],
      "returns": ""
    },
    "curveVertex": {
      "description": "定义曲线顶点的坐标。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。<br><br>在一系列 curveVertex() 线条中第一个和最后一个点将被用来引导曲线的起点和终点。至少必须提供四个点以画一个介于第二和第三个点的小曲线。增加第五个点将会在第二、第三及第四个点之间画个曲线。curveVertex() 函数使用的是 Catmull-Rom 样条函数。",
      "params": ["数字：顶点的 x 坐标",
                 "数字：顶点的 y 坐标"],
      "returns": ""
    },
    "endContour": {
      "description": "使用 beginContour() 及 endContour() 函数以在其他形状内创造剪影形状，比如说 “O” 字母内的空间。beginContour() 将开始记录形状的顶点而 endContour() 则停止记录。定义剪影形状的顶点定义的方向（顺时或逆时针）必须和包含它的形状不同。如果外形的顶点是顺时针方向定义的，那么它里面的形状的顶点需是逆时针方向定义。<br><br>这些函数只能在一对 beginShape()/endShape() 函数之间使用而变形函数如 translate()、rotate() 及 scale() 在一对 beginContour()/endContour() 内并不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在里面使用。",
      "returns": ""
    },
    "endShape": {
      "description": "endShape() 函数和 beginShape() 是一对的而且它只能在 beginShape() 后使用。当 endshape() 被调用时，自上一次 beginShape() 调用后的所有被定义的图像资料将被写进图像缓冲区。定义常量 CLOSE 给 MODE 参数将会关闭该形状（连接起点和终点）。",
      "params": ["常量：使用 CLOSE 以关闭形状"],
      "returns": ""
    },
    "quadraticVertex": {
      "description": "定义二次贝塞尔曲线顶点的坐标。每次调用 quadraticVertex() 将定义贝塞尔曲线的一个控制点和一个锚点，以在线或形状上增加一个新部分。在 beginShape() 内第一次调用 quadraticVertex() 之前必须先调用一次 vertex() 以定义第一个锚点。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。",
      "params": ["数字：控制点的 x 坐标",
                 "数字：控制点的 y 坐标",
                 "数字：锚点的 x 坐标",
                 "数字：锚点的 y 坐标"],
      "returns": ""
    },
    "vertex": {
      "description": "所有形状都是由连接一系列顶点形成的。vertex() 可用于定义点、线、三角形、四角形及多边形的顶点坐标。它只能在 beginShape() 和 endShape() 函数之间使用。",
      "params": ["数字：顶点的 x 坐标",
                 "数字：顶点的 y 坐标",
                 "数字：顶点的 z 坐标",
                 "数字：顶点的纹理 u 坐标",
                 "数字：顶点的纹理 v 坐标"],
      "returns": ""
    },
    "loadModel": {
      "description": "从一个 OBJ 档案加载一个三维模型。<br><br>OBJ 格式的其中一个限制是它没有内建的大小值。这表示不同程式输出的模型可能有非常不同的大小。如果您的模型没被展示的话，请试着调用 loadModel() 并给予 normalized 参数“真”（true）值。这会将模型缩放成适合 p5 的大小。您也可以使用 scale() 函数对您的模型最后大小做与更多的调整。",
      "params": ["字符串：要加载的模型的路径",
                 "布尔值：如果为真，在加载时将模型缩放成标准大小。",
                 "函数(p5.Geometry)：此函数将在模型完成加载后被调用，将被给予该三维模型为参数。",
                 "函数(Event)：如果模型加载失败，此函数将被调用并给予错误事件（event）为参数。"],
      "returns": "p5.Geometry：p5.Geometry 物件"
    },
    "model": {
      "description": "将一个三维模型渲染在荧幕上。",
      "params": ["p5.Geometry：要渲染的已加载的模型"],
      "returns": ""
    },
    "plane": {
      "description": "用给予的宽度和高度画一个平面。",
      "params": ["数字：平面的宽度",
                 "数字：平面的高度",
                 "整数：（可选）在 x 轴的三角形细分数",
                 "整数：（可选）在 y 轴的三角形细分数"],
      "returns": ""
    },
    "box": {
      "description": "用给予的宽度、高度及深度画一个立方体。",
      "params": ["数字：立方体的宽度",
                 "数字：立方体的高度",
                 "数字：立方体的深度",
                 "整数：（可选）在 x 轴的三角形细分数",
                 "整数：（可选）在 y 轴的三角形细分数"],
      "returns": ""
    },
    "sphere": {
      "description": "用给予的半径画一个球形。",
      "params": ["数字：球形的半径",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 16"],
      "returns": ""
    },
    "cylinder": {
      "description": "用给予的半径和高度画一个圆筒形。",
      "params": ["数字：表面的半径",
                 "数字：圆筒形的高度",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：y 轴分割的数量，越多分割几何形越平滑，默认值为 1",
                 "布尔值：是否该画圆筒形的底部",
                 "布尔值：是否该画圆筒形的顶部"],
      "returns": ""
    },
    "cone": {
      "description": "用给予的半径和高度画一个锥体形。",
      "params": ["数字：底部表面的半径",
                 "数字：锥体形的高度",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 1",
                 "布尔值：是否该画锥体形的底部"],
      "returns": ""
    },
    "ellipsoid": {
      "description": "用给予的半径画一个椭球形。",
      "params": ["数字：椭球形 x 轴的半径",
                 "数字：椭球形 y 轴的半径",
                 "数字：椭球形 z 轴的半径",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24。避免多于 150 的细节数量，因为它可能是浏览器停止运作。",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 16。避免多于 150 的细节数量，因为它可能是浏览器停止运作。"],
      "returns": ""
    },
    "torus": {
      "description": "用给予的半径和管半径画一个圆环形。",
      "params": ["数字：整个圆环形的半径",
                 "数字：圆管的半径",
                 "整数：x 轴分割的数量，越多分割几何形越平滑，默认值为 24。",
                 "整数：y 轴分割的数量，越多分割几何形越平滑，默认值为 16。"],
      "returns": ""
    },
    "HALF_PI": {
      "description": "HALF_PI 是个值为 1.57079632679489661923 的数学常量。它是圆形周长与直径的比例的一半。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "PI": {
      "description": "PI 是个值为 3.14159265358979323846 的数学常量。它是圆形周长与直径的比例。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "QUARTER_PI": {
      "description": "QUARTER_PI 是个值为 0.7853982 的数学常量。它是圆形周长与直径的比例的四分之一。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "TAU": {
      "description": "TAU 是 TWO_PI 的别名，是个值为 6.28318530717958647693 的数学常量。它是圆形周长与直径的比例的两倍。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "TWO_PI": {
      "description": "TWO_PI 是个值为 6.28318530717958647693 的数学常量。它是圆形周长与直径的比例的两倍。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "DEGREES": {
      "description": "与 angleMode() 函数一起使用的常量，用于设定 p5.js 如何解读及计算角度（可以是 DEGREES 或 RADIANS）。",
      "returns": ""
    },
    "RADIANS": {
      "description": "与 angleMode() 函数一起使用的常量，用于设定 p5.js 如何解读及计算角度（可以是 DEGREES 或 RADIANS）。",
      "returns": ""
    },
    "preload": {
      "description": "在 setup() 之前被调用，preload() 函数可用来以阻断的方式处理异步加载外来文件。如果 preload 函数有被定义，setup() 将等到其中的加载工作都完成后才开始执行。preload 函数只能含有加载函数（如 loadImage、loadJSON、loadFont、loadStrings 等）。如果您想使用异步加载，加载函数可在 setup() 内或任何其他地方调用，您只需使用其回调函数参数。<br><br>在默认情况下 “loading...” 字眼将会被显示。如果您想只做您自己的加载页面，只需在您也页面上加个 id 为 “p5_loading” 的 HTML 元素。更多详情请查看<a href='http://bit.ly/2kQ6Nio'>这里</a>。",
      "returns": ""
    },
    "setup": {
      "description": "setup() 函数将在程式开始时被调用一次。它可在程序开始时被用来定义初始的环境属性如荧幕大小、背景颜色及媒体加载如图像及字体。每个程序只能有一个 setup() 函数并且他不能在一开始执行后再次被调用。<br><br>请注意：在 setup() 内定义的变量并不能在其他函数内使用，这包括 draw() 。",
      "returns": ""
    },
    "draw": {
      "description": "在 setup() 之后被调用，draw() 函数将持续地重复执行其中的代码直到该程式终止或当 noLoop() 被调用。注意如果 noLoop() 在 setup() 内被调用，draw() 仍然会被执行一个然后才停止。draw() 将会自动被调用并不应该被直接调用。<br><br>您应该使用 noLoop()、redraw() 及 loop() 来控制它。当 noLoop() 停止执行 draw() 内的代码，redraw() 会使 draw() 内的代码执行一次，而 loop() 将会使 draw() 内的代码继续重复执行。<br><br>每一秒 draw() 执行的次数可使用 frameRate() 函数来控制。<br><br>每个绘图只能有一个 draw() 函数，而如果您想持续重复执行代码或处理事件如 mousePressed()，draw() 必须存在。有时候您的程式可能会有空白的 draw() 函数，如以上的范例所示。<br><br>请特别注意绘图坐标系统将在每次 draw() 在开始被调用时重置。任何在 draw() 内执行的变形指令（如 scale、rotate、translate）将会在下一个 draw() 开始时复原，所以变形指令并不会随着时间积累。另一方面，样式（如 fill、stroke等）将会持续同样的效果。",
      "returns": ""
    },
    "remove": {
      "description": "移除整个 p5 绘图。这函数将移除画布及任何由 p5.js 创造的元素。它也会终止绘图循环及解除任何被绑定在窗口对象的属性或函数。它会留下一个 p5 变量以防您还想创造一个新的 p5 绘图。您也可以舍去 p5 = null 以完全删除它。虽然所有由 p5 程式库所创造的函数、变量和物件将会被移除，任何其他由您的代码所定义的公共变量将会被保留。",
      "returns": ""
    },
    "noLoop": {
      "description": "停止 p5.js 持续重复执行 draw() 内的代码。如果 loop() 被调用，draw() 内的代码将开始继续重复执行。如果 noLoop() 在 setup() 被调用，它应该是代码块的最后一行代码。<br><br>在使用 noLoop() 时，您并不能在事件处理函数如 mousePressed() 或 keyPressed() 内操纵或存取荧幕。不过您可以使用哪些函数调用 redraw() 或 loop()，从而执行 draw()，以正确的更新荧幕。这表示当 noLoop() 被调用后，您不能绘制任何东西，同时某些函数如 saveFrame() 或 loadPixels() 也不能使用。<br><br>注意如果绘图的大小改变，redraw() 将会被调用以更新绘图，即使 noLoop() 已经被调用，不然绘图将会处于一个奇怪的状态直到 loop() 再次被调用。",
      "returns": ""
    },
    "loop": {
      "description": "在默认下，p5.js 将会循环执行 draw() 内的代码。不过 draw() 循环能使用 noLoop() 停止。在这情况下 draw() 循环可使用 loop() 函数恢复执行。",
      "returns": ""
    },
    "push": {
      "description": "push() 函数将储存当时的绘画样式设置及变形，而 pop() 将恢复这些设置。注意这两个函数需要一起使用。它们让您改变样式及变形设置然后再回到您之前的设置。当使用 push() 开始一个新的状态时，它将继续建立在当时的样式和变形上。push() 和 pop() 函数可被重复嵌入以提供更复杂的控制。（请参考第二个范例）<br><br>push() 将现有的变形及样式设置资料储存上来，这包括以下的函数：fill()、stroke()、tint()、strokeWeight()、strokeCap()、strokeJoin()、imageMode()、rectMode()、ellipseMode()、colorMode()、textAlign()、textFont()、textMode()、textSize()、textLeading()。",
      "returns": ""
    },
    "pop": {
      "description": "push() 函数将储存当时的绘画样式设置及变形，而 pop() 将恢复这些设置。注意这两个函数需要一起使用。它们让您改变样式及变形设置然后再回到您之前的设置。当使用 push() 开始一个新的状态时，它将继续建立在当时的样式和变形上。push() 和 pop() 函数可被重复嵌入以提供更复杂的控制。（请参考第二个范例）<br><br>push() 将现有的变形及样式设置资料储存上来，这包括以下的函数：fill()、stroke()、tint()、strokeWeight()、strokeCap()、strokeJoin()、imageMode()、rectMode()、ellipseMode()、colorMode()、textAlign()、textFont()、textMode()、textSize()、textLeading()。"
    },
    "redraw": {
      "description": "执行在 draw() 内的代码一次。这函数让该程序只在需要的时候更新显示窗口，比如说当 mousePressed() 或 keyPressed()事件被触发时。<br><br>再构造程式时，只有在如 mousePressed() 之类的时间内调用 redraw() 才有意义，因为 redraw() 并不会直接调用 draw() （它只会表示绘图有需要更新）。<br><br>redraw() 函数并不会在 draw() 内正常运作。以启用/禁用动画，请使用 loop() 及 noLoop()。<br><br>此外您也能定义每次调用 redraw() 将使 draw() 被调用几次。您这需给予一个整数参数已表示执行的次数。",
      "params": ["整数：重绘 n 次。默认值为 1"],
      "returns": ""
    },
    "print": {
      "description": "print() 函数将写入浏览器的控制台区。这函数适用于查看程式生成的资料。这函数每一次被调用将创造新的一行字串。个别元素可使用引号（\"\"）分隔并使用加号（+）连接在一起。",
      "params": ["任何：任何要写进控制台的数字、字符串、物件、布尔值或数组的组合"],
      "returns": ""
    },
    "frameCount": {
      "description": "系统变量 frameCount 存着自程序开始已被展示的影格数量。在 setup() 这值为 0，在第一次执行 draw() 后为 1 等等。",
      "returns": ""
    },
    "focused": {
      "description": "确定 p5.js 程式正在运行的窗口是否获得“焦点”，这表示绘图可接受滑鼠或键盘输入。如果窗口获得焦点，次变量为 “true” 否则为 “false”。",
      "returns": ""
    },
    "cursor": {
      "description" : "设置鼠标成预定的符号或一个图像，或者如果鼠标被隐藏显示鼠标。如果你想要设置一个图像为鼠标，建议的图像大小为 16x16 或 32x32 像素。 It is not possible to load an image as the cursor if you are exporting your program for the Web, and not all MODES work with all browsers. 参数 x 及 y 必须低于图像的大小。",
      "params": ["字符串|常量：ARROW、CROSS、HAND、MOVE、TEXT 或图像的路径",
                 "数字：鼠标的横向活跃点",
                 "数字：鼠标的直向活跃点"],
      "returns": ""
    },
    "frameRate": {
      "description": "定义每一秒应该显示的影格数。比如说，调用 frameRate(30) 将使绘图每秒刷新 30 次。如果处理器没法跟上所定义的速率，该帧率将不会被达到。建议在 setup() 内设置帧率。默认的帧率值为每秒 60 影格。这和调用 setFrameRate(val) 的效果一样。<br><br>调用 frameRate() 但不给予任何参数将会返回当时的帧率。draw() 函数必须至少执行一次它才会返回帧率。这和调用 getFrameRate() 的效果一样。<br><br>调用 frameRate() 并给予任何不是数字或正数的参数也将会返回当时的帧率。",
      "params": ["数字：每一秒该显示的影格数"],
      "returns": ""
    },
    "noCursor": {
      "description": "隐藏鼠标。",
      "returns": ""
    },

    "displayWidth": {
      "description": "储存整个荧幕宽度的系统变量。这可用来在任何大小的荧幕制作任何大小的全屏程序。",
      "returns": ""
    },
    "displayHeight": {
      "description": "储存整个荧幕高度的系统变量。这可用来在任何大小的荧幕制作任何大小的全屏程序。",
      "returns": ""
    },
    "windowWidth": {
      "description": "储存窗口内部宽度的系统变量， 此函数映射 window.innerWidth。",
      "returns": ""
    },
    "windowHeight": {
      "description": "储存窗口内部高度的系统变量， 此函数映射 window.innerHeight。",
      "returns": ""
    },
    "windowResized": {
      "description": "windowResized() 函数将在每次浏览器窗口缩放时被调用。这是个适合缩放画布及或任何其他调整以符合新的窗口大小的地方。",
      "returns": ""
    },
    "width": {
      "description": "储存画布宽度的系统变量。这值是由 createCanvas() 函数的第一个参数所定义。比如说，调用函数 createCanvas(320, 240) 将定义此宽度变量为 320。如果一个程式没有使用 createCanvas() 宽度值将默认为 100。",
      "returns": ""
    },
    "height": {
      "description": "储存画布高度的系统变量。这值是由 createCanvas() 函数的第二个参数所定义。比如说，调用函数 createCanvas(320, 240) 将定义此高度变量为 240。如果一个程式没有使用 createCanvas() 高度值将默认为 100。",
      "returns": ""
    },
    "fullscreen": {
      "description": "如果提供一个参数，依该参数而定该绘图是否是全屏。如果没有给予任何参数，将返回当时的全屏状态。注意因为浏览器限制，此函数只能在使用者输入时调用，比如说在滑鼠点击时如以上范例。",
      "params": ["布尔值：该绘图是否应该是全屏"],
      "returns": "布尔值：当时的全屏状态"
    },
    "pixelDensity": {
      "description": "定义像素缩放值，用于高像素密度显示器。默认像素密度为显示器的像素密度，可调用 pixelDensity(1) 以关闭此功能。调用 pixelDensity() 并不给予任何参数将返回该绘图的像素密度。",
      "params": ["数字：绘图是否应该缩放及缩放多少"],
      "returns": "数字：该绘图的像素密度"
    },
    "displayDensity": {
      "description": "返回正在运行该绘图的显示器的像素密度。",
      "returns": "数字：该显示器的像素密度"
    },
    "getURL": {
      "description": "返回当下的网址。",
      "returns": "字符串：网址"
    },
    "getURLPath": {
      "description": "返回当下的网址的路径数组",
      "returns": "字符串[]：路径组"
    },
    "getURLParams": {
      "description": "返回当下网址的参数物件",
      "returns": "物件：网址参数"
    },

    "createCanvas": {
      "description": "在文件内创造一个画布元素，并以像素定义其大小。这函数只应该在 setup() 开始时被调用一次。在同一个绘图里调用 createCanvas 多过一次将造成难以预料的行为。如果你想要使用多过一个绘图画布您可以使用 createGraphics（默认上会被隐藏可是可以被显示）。<br><br>给予这函数的宽度和高度参数将被用来定义 width 和 height 系统变量。如果 createCanvas() 没有被使用，画布将会被给予默认大小 100x100。<br><br>以知更多放置画布的方法，请参考<a href='https://github.com/processing/p5.js/wiki/Positioning-your-canvas'>画布放置维基</a>（英文页面）。",
      "params": ["数字：画布的宽度",
                 "数字：画布的高度",
                 "常量：P2D 或 WEBGL"],
      "returns": "p5.Renderer："
    },
    "resizeCanvas": {
      "description": "缩放画布至给予的宽度和高度。该画布将会马上被清空及调用 draw()，使得画布能在缩放后重新渲染。",
      "params": ["数字：画布的宽度",
                 "数字：画布的高度",
                 "布尔值：不要马上更新画布"],
      "returns": ""
    },
    "noCanvas": {
      "description": "如果该 p5 绘图不需要画布，此函数将移除默认画布。",
      "returns": ""
    },
    "createGraphics": {
      "description": "创造及返回一个新的 p5.Renderer 物件。如果您需要在一个画面外的图形缓冲区作画，您可以使用这个函数。前两个参数将定义宽度和高度像素。",
      "params": ["数字：画面外图形缓冲区的宽度",
                 "数字：画面外图形缓冲区的高度",
                 "常量：P2D 或 WEBGL，默认为 P2D"],
      "returns": "buffer gráfico fuera de pantalla"
    },
    "blendMode": {
      "description": "根据所设定的模式在显示窗口内混合像素。以下模式选择可用来混合源像素（A）与已经在显示窗口的像素（B）：<ul><li><code>BLEND</code> - 颜色线性插值：C = A*系数 + B。这是默认混合模式。</li><li><code>ADD</code> - A 与 B 的总和</li><li><code>DARKEST</code> - 将显示当中最深的颜色：C = min(A*系数, B)。</li><li><code>LIGHTEST </code> - 将显示当中最浅的颜色：C = max(A*系数, B)。</li><li><code>DIFFERENCE</code> - 从底下的图像中减去颜色。</li><li><code>EXCLUSION</code> - 与 DIFFERENCE 相似但不那么强烈。</li><li><code>MULTIPLY</code> - 将颜色相乘，效果一定会更暗。</li><li><code>SCREEN</code> - 与 MULTIPLY 相反，使用颜色的反值。</li><li><code>REPLACE</code> - 像素将完全盖过其他像素并将不会使用透明度值。</li><li><code>OVERLAY</code> - MULTIPLY 及 SCREEN 和混合。暗值将相乘，亮值将相乘反值。</li><li><code>HARD_LIGHT</code> - 当高于 50% 灰时 SCREEN，低于时 MULTIPLY。</li><li><code>SOFT_LIGHT</code> - DARKEST 及 LIGHTEST 的混合。与 OVERLAY 的效果相似，但不那么强烈。</li><li><code>DODGE</code> - 使浅色更浅及增加对比度，忽略暗色。</li><li><code>BURN</code> - 是深色更深及增加对比度，忽略浅色。</li></ul>",
      "params": ["常量：画布的混合模式。BLEND、DARKEST、LIGHTEST、DIFFERENCE、MULTIPLY、EXCLUSION、SCREEN、REPLACE、OVERLAY、HARD_LIGHT、SOFT_LIGHT、DODGE、BURN、ADD 或 NORMAL"],
      "returns": ""
    },
    "setAttributes": {
      "description": "设置 WebGL 绘图环境的属性。这是调整 WebGL 渲染器的一个方法，可用于微调显示及性能。这函数应该在 setup() 内使用。可使用的属性为：<br>alpha - 表示画布是否有透明度缓冲，默认为 true<br><br>depth - 表示绘图缓冲是否有至少 16 bits 的深度缓冲 - 默认为 true<br><br>stencil - 表示绘图缓冲是否有至少 8 bits 的模版缓冲<br><br>antialias - 表示是否应该执行抗锯齿，默认为 false<br><br>premultipliedAlpha - 表示页面合成器将假设绘图缓冲存在着预乘透明值的颜色，默认为 false<br><br>preserveDrawingBuffer - 如果为真缓冲区将不会被清空并将会保留现有的值直到它们被清空或被作者覆盖（注意 p5 在绘图循环将自动清空），默认为 true<br><br>perPixelLighting - 如果为真，照明着色器将使用个别像素照明。默认为 false",
      "params": ["字符串：属性名",
                 "布尔值：属性的新值",
                 "物件：有键值对的物件"]
    },
    "applyMatrix": {
      "description": "将现有的矩阵乘于由参数所定义的矩阵。这是个强大的功能并能够同时执行平移、缩放、切变及旋转。您能在<a href='https://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5'>维基百科</a>了解更多关于变形矩阵的资讯。<br><br>这里的参数命名跟着 <a href='https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-transform'>WHATWG 规范</a>（英文页面）的命名方式并代表着一个如下的变形矩阵：<blockquote><p><img style='max-width: 150px' src='assets/transformation-matrix.png' alt='当 applyMatrix 被调用时所使用的变形矩阵'></p></blockquote>",
      "params": ["数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵"],
      "returns": ""
    },
    "resetMatrix": {
      "description": "将现有的矩阵替换成单位矩阵。",
      "returns": ""
    },
    "rotate": {
      "description": "将一个形状根据参数所定义的角度旋转。这函数将考虑角度模式，所以角度可以是弧度或角度定义。<br><br>所有物件都会绕着原点旋转而正数将使物件在顺时针方向旋转。此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积。比如说，调用 rotate(HALF_PI) 然后 rotate(HALF_PI) 效果会与 rotate(PI) 相同。所有变形将会在 draw() 重新开始时恢复。",
      "params": ["数字：旋转的角度，根据当时的角度模式，以弧度或角度定义",
                 "p5.Vector|数字[]：（3D 模式下）旋转轴"],
      "returns": ""
    },
    "rotateX": {
      "description": "绕着 x 轴旋转。",
      "params": ["数字：旋转角度，根据当时的角度模式，以弧度或角度定义"],
      "returns": ""
    },
    "rotateY": {
      "description": "绕着 y 轴旋转。",
      "params": ["数字：旋转角度，根据当时的角度模式，以弧度或角度定义"],
      "returns": ""
    },
    "rotateZ": {
      "description": "绕着 x 轴旋转。只适用于 WEBGL 模式。",
      "params": ["数字：旋转角度，根据当时的角度模式，以弧度或角度定义"],
      "returns": ""
    },
    "scale": {
      "description": "通过扩大和收缩顶点，放大或缩小形状。形状物件将会从坐标系统的原点开始缩放。缩放值为十进制百分比。比如说，调用函数 scale(2.0) 将使该形状放大 200%。<br><br>此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积相乘。比如说，调用 scale(2.0) 然后 scale(1.5) 效果会与 scale(3.0) 相同。如果 scale() 在 draw() 内被调用，变形将会在下一次循环开始时恢复。<br><br>给予此函数一个 z 参数只在 WEBGL 模式下受支持。这函数能使用 push() 及 pop() 控制。",
      "params": ["数字|p5.Vector|数字[]：缩放物件的百分比，或如果给予多个参数 x 轴的缩放百分比",
                 "数字：y 轴的缩放百分比",
                 "数字：z 轴的缩放百分比（只适用于 WEBGL 模式）",
                 "p5.Vector|数字[]：各轴缩放百分比"],
      "returns": ""
    },
    "shearX": {
      "description": "有角度参数所定义的形状 x 轴切变量。角度必须符合当时的角度模式。形状物件将会从坐标系统的原点开始切变而正数表示切变方向为顺时针方向。<br><br>此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积。比如说，调用 shearX(PI/2) 然后 shearX(PI/2) 效果会与 shearX(PI) 相同。如果 shearX() 在 draw() 内被调用，变形将会在下一次循环开始时恢复。<br><br>技术上，shearX() 将现有的变形矩阵乘以一个旋转矩阵。这函数能使用 push() 及 pop() 控制。",
      "params": ["数字：根据当时的角度模式，以弧度或角度定义和切变角度"],
      "returns": ""
    },
    "shearY": {
        "description": "有角度参数所定义的形状 y 轴切变量。角度必须符合当时的角度模式。形状物件将会从坐标系统的原点开始切变而正数表示切变方向为顺时针方向。<br><br>此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积。比如说，调用 shearY(PI/2) 然后 shearY(PI/2) 效果会与 shearY(PI) 相同。如果 shearY() 在 draw() 内被调用，变形将会在下一次循环开始时恢复。<br><br>技术上，shearY() 将现有的变形矩阵乘以一个旋转矩阵。这函数能使用 push() 及 pop() 控制。",
        "params": ["数字：根据当时的角度模式，以弧度或角度定义和切变角度"],
        "returns": ""
    },
    "translate": {
      "description": "定义在显示窗口内平移物件的量。x 参数将定义左/右平移，y 参数将定义上/下平移。<br><br>此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积。比如说，调用 translate(50, 0) 然后 translate(20, 0) 效果会与 translate(70, 0) 相同。如果 translate() 在 draw() 内被调用，变形将会在下一次循环开始时恢复。这函数能使用 push() 及 pop() 控制。",
      "params": ["数字：左/右平移",
                 "数字：上/下平移",
                 "数字：前/后平移（只适用于 WEBGL 模式）",
                 "p5.Vector：平移向量"],
      "returns": ""
    },

    "deviceOrientation": {
      "description": "deviceOrientation 系统变量将会储存设备的旋转方向。此变量的值可以是 ‘landscape’ 或 ‘portrait’。如果没有资料可用他会被定义成 ‘undefined’。LANDSCAPE 或 PORTRAIT。",
      "returns": ""
    },
    "accelerationX": {
      "description": "accelerationX 系统变量将会储存设备的 x 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "accelerationY": {
      "description": "accelerationY 系统变量将会储存设备的 y 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "accelerationZ": {
      "description": "accelerationZ 系统变量将会储存设备的 z 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "pAccelerationX": {
      "description": "pAccelerationX 系统变量将会储存上一个影格该设备的 x 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "pAccelerationY": {
      "description": "pAccelerationY 系统变量将会储存上一个影格该设备的 y 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "pAccelerationZ": {
      "description": "pAccelerationZ 系统变量将会储存上一个影格该设备的 z 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "rotationX": {
      "description": "rotationX 系统变量将会储存设备在 x 轴的旋转角度。值介于 0 与 +/-180 度之间。<br><br>注意：旋转的顺序很重要，比如说，如果同时使用它们必须依 Z-X-Y 的顺序调用或可能会有难以预料的行为。",
      "returns": ""
    },
    "rotationY": {
      "description": "rotationY 系统变量将会储存设备在 y 轴的旋转角度。值介于 0 与 +/-90 度之间。<br><br>注意：旋转的顺序很重要，比如说，如果同时使用它们必须依 Z-X-Y 的顺序调用或可能会有难以预料的行为。",
      "returns": ""
    },
    "rotationZ": {
      "description": "rotationZ 系统变量将会储存设备在 z 轴的旋转角度。值介于 0 与 359 度之间。<br><br>与 rotationX 及 rotationY 不同的是，这变量只能在有内建指南针的设备使用。<br><br>注意：旋转的顺序很重要，比如说，如果同时使用它们必须依 Z-X-Y 的顺序调用或可能会有难以预料的行为。",
      "returns": ""
    },
    "pRotationX": {
      "description": "pRotationX 系统变量将会储存上一个影格该设备在 x 轴的旋转角度。值介于 0 与 +/-180 度之间。<br><br>pRotationX 可以和 rotationX 一起使用以找出设备 x 轴的旋转方向。",
      "returns": ""
    },
    "pRotationY": {
      "description": "pRotationY 系统变量将会储存上一个影格该设备在 y 轴的旋转角度。值介于 0 与 +/-90 度之间。<br><br>pRotationY 可以和 rotationY 一起使用以找出设备 y 轴的旋转方向。",
      "returns": ""
    },
    "pRotationZ": {
      "description": "pRotationZ 系统变量将会储存上一个影格该设备在 z 轴的旋转角度。值介于 0 与 359 度之间。<br><br>pRotationZ 可以和 rotationZ 一起使用以找出设备 z 轴的旋转方向。",
      "returns": ""
    },
    "setMoveThreshold": {
      "description": "setMoveThreshold() 函数可用来设置 deviceMoved() 函数的移动阈值。默认阈值为 0.5。",
      "params": ["数字：阈值"],
      "returns": ""
    },
    "setShakeThreshold": {
      "description": "setShakeThreshold() 函数可用来设置 deviceShaken() 函数的摇动阈值。默认阈值为 30。",
      "params": ["数字：阈值"],
      "returns": ""
    },
    "deviceMoved": {
      "description": "deviceMoved() 函数将在设备在 X、Y 或 Z 轴被移动多过阈值时被调用。默认阈值为 0.5。",
      "returns": ""
    },
    "deviceTurned": {
      "description": "deviceTurned() 函数将在设备被连续旋转多过 90 度时被调用。<br><br>触发 deviceTurned() 的旋转轴将被储存在 turnAxis 变量中。deviceTurned() 函数能被锁定在 X、Y 或 Z 以确保只有所定义的轴会导致函数被调用，您只需比较 turnAxis 变量和 'X'、'Y' 或 'Z' 字符串。",
      "returns": ""
    },
    "deviceShaken": {
      "description": "deviceShaken() 函数将在设备的 accelerationX 及 accelerationY 加速度值改变超过阈值。默认阈值为 30。",
      "returns": ""
    },
    "keyIsPressed": {
      "description": "keyIsPressed 布尔系统变量将会在任何键被按下时为真（true）而没键被按下时为假（false）。",
      "returns": ""
    },
    "key": {
      "description": "key 系统变量将会储存上一个被键入的键盘键值。以获得正确的大小写，最好在 keyTyped() 内使用。至于非 ASCII 值的键，请使用 keyCode 变量。",
      "returns": ""
    },
    "keyCode": {
      "description": "keyCode 变量可用来探测特别键如 BACKSPACE、DELETE、ENTER、RETURN、TAB、ESCAPE、SHIFT、CONTROL、OPTION、ALT、UP_ARROW、DOWN_ARROW、LEFT_ARROW、RIGHT_ARROW 是否被按下。您也可以使用特别网站如 <a href='http://keycode.info/'>keycode.info</a> 以找出自定义键的 keyCode。",
      "returns": ""
    },
    "keyPressed": {
      "description": "keyPressed() 函数将会在每一次任何键被按下时被调用。被按下的键的 keyCode 将被储存在 keyCode 变量内。<br><br>对于非 ASCII 值的键，请使用 keyCode 变量。您能查看 keyCode 是否等于 BACKSPACE、DELETE、ENTER、RETURN、TAB、ESCAPE、SHIFT、CONTROL、OPTION、ALT、UP_ARROW、DOWN_ARROW、LEFT_ARROW、RIGHT_ARROW。<br><br>至于 ASCII 键值它们的值会被储存在 key 变量内。不过，它并不会分辨大小写。因此，建议使用 keyTyped() 以读取 key 变量，因为其大小写在这里会被分辨出来。<br><br>取决于操作系统如何处理按键重复，按住一个键可能使 keyTyped() （及 keyReleased()）被调用多过一次。重复的速度应操作系统及该电脑的设置而定。<br><br>不同浏览器可能会有不同附属于个别键盘事件的默认行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "keyReleased": {
      "description": "keyReleased() 函数将会在每一次任何键被释放时被调用。请查看 key 及 keyCode 以知更多详情。<br><br>不同浏览器可能会有不同附属于个别键盘事件的默认行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "keyTyped": {
      "description": "keyTyped() 函数将会在每一次任何键被按下时被调用，可是会忽略操作键如 Ctrl、Shift 及 Alt。被按下的键的 keyCode 将被储存在 keyCode 变量内。<br><br>取决于操作系统如何处理按键重复，按住一个键可能使 keyTyped() （及 keyReleased()）被调用多过一次。重复的速度应操作系统及该电脑的设置而定。<br><br>不同浏览器可能会有不同附属于个别键盘事件的默认行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "keyIsDown": {
      "description": "keyIsDown() 函数将查看被提供的键是否正被按下。它能在当您需要使用多个不同的键同时用来移动一个物件时使用（如将一个图像往斜移动）。您能给予任何代表该键的 keyCode 会任何<a href='http://p5js.org/zh-Hans/reference/#p5/keyCode'>此页</a>的 keyCode 变量名为参数。",
      "params": ["数字：该查看的键"],
      "returns": ""
    },
    "mouseX": {
      "description": "mouseX 系统变量将会储存当时的鼠标相对于画布 (0, 0) 位置的的横向位置。如果使用的是触动而不是滑鼠的话，mouseX 将会储存上一个触动点的 x 值。",
      "returns": ""
    },
    "mouseY": {
      "description": "mouseY 系统变量将会储存当时的鼠标相对于画布 (0, 0) 位置的的直向位置。如果使用的是触动而不是滑鼠的话，mouseY 将会储存上一个触动点的 y 值。",
      "returns": ""
    },
    "pmouseX": {
        "description": "pmouseX 系统变量将会储存上一个影格鼠标或触动点相对于画布 (0, 0) 位置的的横向位置。",
        "returns": ""
    },
    "pmouseY": {
      "description": "pmouseY 系统变量将会储存上一个影格鼠标或触动点相对于画布 (0, 0) 位置的的直向位置。",
      "returns": ""
    },
    "winMouseX": {
      "description": "winMouseX 系统变量将会储存当时鼠标相对于窗口 (0, 0) 位置的横向位置。",
      "returns": ""
    },
    "winMouseY": {
      "description": "winMouseY 系统变量将会储存当时鼠标相对于窗口 (0, 0) 位置的直向位置。",
      "returns": ""
    },
    "pwinMouseX": {
      "description": "pwinMouseX 系统变量将会储存上一个影格鼠标相对于窗口 (0, 0) 位置的横向位置。",
      "returns": ""
    },
    "pwinMouseY": {
      "description": "pwinMouseY 系统变量将会储存上一个影格鼠标相对于窗口 (0, 0) 位置的直向位置。",
      "returns": ""
    },
    "mouseButton": {
      "description": "p5 将自动记录滑鼠键是否被按下及哪个键被按下。mouseButton 系统变量的值可能是 LEFT、RIGHT 或 CENTER，取决于上一个被按下的滑鼠键。请注意：不同的浏览器可能记录不同的 mouseButton 值。",
      "returns": ""
    },
    "mouseIsPressed": {
      "description": "mouseIsPressed 系统变量将会在滑鼠键被按下时为真（true），而没按下时为假（false）。",
      "returns": ""
    },
    "mouseMoved": {
      "description": "mouseMoved() 函数将在每次鼠标移动而滑鼠键没有被按下的时候被调用。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "mouseDragged": {
      "description": "mouseDragged() 函数将在每次鼠标移动及滑鼠键正被按下的时候被调用。如果 mouseDragged() 函数并未有被定义，touchMoved() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "mousePressed": {
      "description": "mousePressed() 函数将在每次滑鼠键被按下时被调用。mouseButton 函数（请参考其文献）可以被用来探测哪一个滑鼠键刚被按下。如果 mousePressed() 函数并未有被定义，touchStarted() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "mouseReleased": {
      "description": "mouseReleased() 函数将在每次滑鼠键被释放时被调用。如果 mouseReleased() 函数并未有被定义，touchEnded() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "mouseClicked": {
      "description": "mouseClicked() 函数将在滑鼠键被按下然后被释放后被调用。<br><br>不同浏览器处理滑鼠点击的方式不大一样，所以这函数只有在滑鼠左键被点击时才保证会被触发。如果想要处理其他滑鼠键的点击或释放事件，请参考 mousePressed() 或 mouseReleased()。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "doubleClicked": {
      "description": "doubleClicked() 函数将在 dblclick 事件被触发式被调用，dblclick 时间是 DOM L3 规范的一部分。doubleClicked 将在滑鼠键（通常为左键）连续两次在同样一个元素上点击时被触发。以知更多详情请参考 Mozilla 的参考文献：<a href='https://developer.mozilla.org/en-US/docs/Web/Events/dblclick'>https://developer.mozilla.org/en-US/docs/Web/Events/dblclick</a>。"
    },
    "mouseWheel": {
      "description": "mouseWheel() 函数将在每次直向滑鼠滚轮事件被触发式被调用，可以由实际的滑鼠滚轮或摸板触发。<br><br>event.delta 属性将返回滑鼠滚轮所滚动的量。这值可以是正数或负数，取决于滚动的方向（在 OS X 如果启用“自然”滚屏方向，正反方向将相反）。",
      "returns": ""
    },
    "touches": {
      "description": "touches[] 系统变量将储存一个含有现在所有触动点相对于画布 (0, 0) 位置的位置数组，及分辨个别触动点移动时的 ID。数组内的每个元素都会有 x、y 及 id 属性。<br><br>touches[] 数组并不受 Safari 及 IE 移动设备（包括手提电脑）所支持。",
      "returns": ""
    },
    "touchStarted": {
      "description": "touchStarted() 函数将在每次触动事件被触发时被调用。如果 touchStarted() 函数并未有被定义，mousePressed() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别触动事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "touchMoved": {
      "description": "touchMoved() 函数将在每次触点移动事件被触发时被调用。如果 touchMoved() 函数并未有被定义，mouseDragged() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别触动事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "touchEnded": {
      "description": "touchEnded() 函数将在每次触动结束时被调用。如果 touchEnded() 函数并未有被定义，mouseReleased() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别触动事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "createImage": {
      "description": "创造一个新的 p5.Image 物件（储存图像的数据类型）。这将提供一个全新的像素缓冲供您使用。缓冲区的大小将由所提供的宽度和高度参数决定。<br><br>.pixels 将提供一个含有所有像素资料的数组。这些值都为数字。这数组的大小为（同时考虑像素密度）显示窗口的大小 x4，分别代表每个像素由左到右，上到下的 R、G、B、A 值。请参考 .pixels 文献。您也能使用更简单的 set() 或 get()。<br><br>在获取一个图像的像素之前，像素资料必须先使用 loadPixels() 函数加载。在数组资料被修改后，updatePixels() 函数必须被调用以更新图像资料。",
      "params": ["整数：像素宽度",
                 "整数：像素宽度"],
      "returns": "p5.Image：p5.Image 物件"
    },
    "saveCanvas": {
      "description": "将现有的画布储存成图像。In Safari, this will open the image in the window and the user must provide their own filename on save-as. Other browsers will either save the file immediately, or prompt the user with a dialogue window.",
      "params": ["p5.Element|HTMLCanvasElement：una variable representando un canvas HTML5 específico (opcional)",
                 "字符串",
                 "字符串：'jpg' 或 'png'"],
      "returns": ""
    },
    "saveFrames": {
      "description": "捕捉一系列可用于制作影响的影格图像。接受回调函数。比如说，您可能想要将影格传送至伺服器以方便储存或转变成影像。如果回调函数没有被提供，浏览器将弹出储存文件对话框以尝试下载所有刚被创造的图像。如果提供回调函数，图像资料默认上并不会被储存而是以物件数组的形式被转送至回调函数做参数，数组大小为储存影格的总数。",
      "params": ["字符串",
                 "字符串：'jpg' 或 'png'",
                 "数字：该捕捉的影格的秒数",
                 "数字：捕捉影格的帧率",
                 "函数(数组)：一个用来处理图像资料的回调函数。此函数将会被给予一个数组为参数。此数组将会储存所定义的捕捉影格物件。每一个物件都会有三个属性：imageData - 为 image/octet-stream 类型、filename 及 extension。"],
      "returns": ""
    },
    "loadImage": {
      "description": "从被给予的路径加载一个图像并使用其图像创造一个  p5.Image 物件。<br><br>该图像或许不能立刻被渲染，如果您想要保证您在图像加载完毕后才开始做任何事情，您可以将 loadImage() 函数调用在 preload() 里。您也能提供回调函数以在图像加载完毕时处理图像资料。<br><br>图像的路径应该相对于链接您的绘图的 HTML 文件。从其他 URL 或远程位置加载图像可能会被浏览器的内建安全模式阻止。",
      "params": ["字符串：欲加载的图像的路径",
                 "函数(p5.Image)：图像加载结束调用的函数。会被给予 p5.Image 做参数。",
                 "函数(错误物件)：如果图像加载失败此函数将被调用并给予错误物件做参数。"],
      "returns": "p5.Image：p5.Image 物件"
    },
    "image": {
      "description": "在 p5 画布上画一个图像。<br><br>此函数能使用几个不同数量的参数。最简单的用法只需要三个参数：img（图像）、x 及 y - (x, y) 为图像的位置。多两个可选参数能用来定义绘制图像的宽度及高度。<br><br>此函数也能使用所有八个数字参数。以分辨所有的参数，p5.js 在以下将使用“终点方形”（应对于 “dx”、“dy” 等）及“原图像”（应对于 “sx”、“sy”等）的名词。提供“原图像”大小可用来显示原图像的一个子部分而不需要显示整个图像。以下图表能解释得更清楚：<img src='assets/drawImage.png'>",
      "params": ["p5.Image|p5.Element：该显示的图像",
                 "数字：图像左上角的 x 坐标",
                 "数字：图像左上角的 y 坐标",
                 "数字：绘制图像的宽度",
                 "数字：绘制图像的高度",
                 "数字：绘制图像的终点方形的 x 坐标位置",
                 "数字：绘制图像的终点方形的 y 坐标位置",
                 "数字：终点方形的宽度",
                 "数字：终点方形的高度",
                 "数字：该画进终点方形的原图像子部分的 x 坐标",
                 "数字：该画进终点方形的原图像子部分的 y 坐标",
                 "数字：该画进终点方形的原图像子部分的宽度",
                 "数字：该画进终点方形的原图像子部分的高度"],
      "returns": ""
    },
    "tint": {
      "description": "定义显示图像的填色值。图像能着色成所定义的颜色或提供透明度值以使其透明化。<br><br>如想是图像透明化但不想影响其颜色，可使用白色为着色值并定义透明度值。比如说，tint(255, 128) 将会使一个图像成为 50% 透明（假设为默认透明度范围 0-255，可使用 colorMode() 调整）。<br><br>灰阶值参数必须低于或等于当时 colorMode() 所定义的最高值。默认最高值为 255。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "数字：",
                 "字符串：颜色字符串",
                 "数字：灰阶值",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color：着色色值"],
      "returns": ""
    },
    "noTint": {
      "description": "移除当时显示图像的填色值并将其恢复成显示图形的原色调。",
      "returns": ""
    },
    "imageMode": {
      "description": "定义图像模式。更改 image() 解读参数的方式以更改图像开始绘制的位置。默认模式为 imageMode(CORNER)，此模式将解读第二及第三个参数为图像的左上角位置。如果加多两个参数，它们则被用来定义图像的宽度和高度。<br><br>imageMode(CORNERS) 将使 image() 函数解读第二及第三个参数为一个角落的位置，而第四个第五个参数为对面角落的位置。<br><br>imageMode(CENTER) 将使 image() 函数解读第二及第三个参数为图像的中心点。如果提供多两个参数，它们将被用来定义图像的宽度和高度。",
      "params": ["常量：CORNER、CORNERS 或 CENTER"],
      "returns": ""
    },
    "pixels": {
      "description": "此数组为一个储存显示窗口内所有像素值的 Uint8ClampedArray。这些值都为数字。这数组的大小为（同时考虑像素密度）显示窗口的大小 x4，分别代表每个像素由左到右，上到下的 R、G、B、A 值。视网膜显示及其他高密度显示器将会有更多像素（pixelDensity^2 倍）。比如说，如果图像为 100x100 像素，总共会有 40,000 个元素在 pixels[] 数组内。而在一个视网膜显示，将会有 160,000 个元素。<br><br>数组内最初四个值（指数 0-3）将会是在坐标 (0, 0) 的像素的 R、G、B、A 值。下四个值（指数 4-7）将会是在坐标 (1, 0) 的像素的 R、G、B、A 值。一般上，如果要设置像素 (x, y) 的值： <pre>CODE BLOCK PENDING</pre> 虽然以上的方式有点复杂，它能提供足够的弹性以应对任何像素密度的显示。注意 set() 将会自动处理设定所有在任何像素密度下 (x, y) 坐标在 pixels[] 内的值，不过程序性能可能在像素数组被更改很多次时时不佳。<br><br>在使用这个数组之前，像素资料必须先使用 loadPixels() 函数加载。在数组资料被修改后，updatePixels() 函数必须被调用以更新图像资料。<br><br>注意这不是个普通的 Javascript 数组。这表示 Javascript 数组函数如 <code>slice()</code> 或 <code>arrayCopy()</code> 将不会有效果。",
      "returns": ""
    },
    "blend": {
      "description": "将一个图像内一个区域的像素复制去另一个图像，同时使用所定义的混合模式执行复制。",
      "params": ["p5.Image：原图像",
                 "整数：原图像的左上角 x 坐标",
                 "整数：原图像的左上角 y 坐标",
                 "整数：原图像的宽度",
                 "整数：原图像的高度",
                 "整数：终点图像左上角的 x 坐标",
                 "整数：终点图像左上角的 y 坐标",
                 "整数：终点图像的宽度",
                 "整数：终点图像的高度",
                 "常量：混合模式。BLEND、DARKEST、LIGHTEST、DIFFERENCE、MULTIPLY、EXCLUSION、SCREEN、REPLACE、OVERLAY、HARD_LIGHT、SOFT_LIGHT、DODGE、BURN、ADD 或 NORMAL。"],
      "returns": ""
    },
    "copy": {
      "description": "将画布内一个区域的像素复制去画布内另外一个区域同时也复制一个由 srcImg 参数所定义的图像内一个区域的像素去定义 srcImage 的画布上，这将是原图像。如果原图像与重点区域的大小不同，它将会自动缩放原图像的像素以符合所定义的终点区域。",
      "params": ["p5.Image：原图像",
                 "整数：原图像的左上角 x 坐标",
                 "整数：原图像的左上角 y 坐标",
                 "整数：原图像的宽度",
                 "整数：原图像的高度",
                 "整数：终点图像左上角的 x 坐标",
                 "整数：终点图像左上角的 y 坐标",
                 "整数：终点图像的宽度",
                 "整数：终点图像的高度"],
      "returns": ""
    },
    "filter": {
      "description": "在画布上使用过滤器。<br><br>预设选择为：<br><br>THRESHOLD 将图像转换成黑与白像素，取决于它们是否高于或低于所定义的 level 参数值。参数值必须在 0.0（黑色）与 1.0（白色）之间。如果并没有提供参数的话，默认将设为 0.5。<br><br>GRAY 将图像内的颜色转换成灰阶色。不使用任何参数。<br><br>OPAQUE 设置所有透明度值成完全不透明。不使用任何参数。<br><br>INVERT 设置每个像素成其反值。不使用任何参数。<br><br>POSTERIZE 将限制每个图像的彩色通道至参数所定义的颜色数。参数值可以介于 2 至 255 之间，但是效果会在较低值是比较明显。<br><br>BLUR 将使用 level 参数所定义的模糊度执行高斯模糊。如果没有提供参数，模糊度为高斯模糊半径为 1。越大的值越模糊。<br><br>ERODE 减少亮区。不使用任何参数。<br><br>DILATE 增加亮区。不使用任何参数。",
      "params": ["常量：THRESHOLD、GRAY、OPAQUE、INVERT、POSTERIZE、BLUR、ERODE、DILATE 或 BLUR。",
                 "数字：每个过滤器独有的可选性参数，请看以上"],
      "returns": ""
    },
    "get": {
      "description": "返回任何像素值的一个为 [R,G,B,A] 的数组或捕捉图像的一部分。如果没有提供任何参数，将会返回整个图像。可使用 x 及 y 参数以取得一个像素的值。多加定义 w 及 h 参数可取的显示窗口的一部分。当在取得图像时，x 及 y 参数将定义图像的左上角坐标值，无论当时的图像模式为何。<br><br>如果欲取得的像素在图像外，将返回 [0,0,0,255]。以取得根据当时的颜色值范围及颜色模式的数字，请使用 getColor 而不是 get。<br><br>使用 get(x, y) 以取得一个像素的颜色相对来说简单，但是其速度并没有直接从 pixels[] 数组获取数据来的快。与使用 get(x, y) 有相同的效果但使用 pixels[] 及像素密度 d 的范例如下 <code>var x, y, d; // 设置这为坐标 var off = (y width + x) d * 4; var components = [ pixels[off], pixels[off + 1], pixels[off + 2], pixels[off + 3] ]; print(components);</code><br><br>请参考 pixels[] 文献以知更多详情。",
      "params": ["数字：像素的 x 坐标",
                 "数字：像素的 y 坐标",
                 "数字：宽度",
                 "数字：高度"],
      "returns": "数字[]|p5.Image：在 x,y 的像素值数组或 p5.Image"
    },
    "loadPixels": {
      "description": "将显示窗口的像素资料加载到 pixels[] 数组里。这函数必须在读写 pixels[] 之前被调用。注意只有使用 set() 或直接修改 pixels[] 的改变会发生。",
      "returns": ""
    },
    "set": {
      "description": "改变任何像素的颜色，或直接在显示窗口内绘画一个图像。<br><br>x 及 y 参数用于定义该改变的像素而 c 参数用于定义颜色值。这可以是一个 p5.Color 物件或一个 [R, G, B, A] 像素数组。它也能是一个灰阶值。在设定一个图像时，x 及 y 参数将定义图像左上角的坐标值，无论当时的图像模式为何。<br><br>在使用 set() 后，您必须调用 updatePixels() 以使您的改变生效。这应该在所有像素都被设定后才被调用，而且也必须在调用 get() 或绘制图像之前调用。<br><br>使用 set(x, y) 设置一个像素的颜色相对来说简单，但使其速度并没有直接将数据写在 pixels[] 数组里来的快。直接使用 pixels[] 设置像素值可能在使用视网膜显示器时比较复杂，不过它会在每一个循环有很多像素需要被设定时表现得更好。<br><br>请参考 pixels[] 文献以知更多详情。",
      "params": ["数字：像素的 x 坐标",
                 "数字：像素的 y 坐标",
                 "数字|数字[]|物件：插入一个灰阶值 | 一个像素数组 | 一个 p5.Color 物件 | 一个用于复制的 p5.Image"],
      "returns": ""
    },
    "updatePixels": {
      "description": "使用 pixels[] 数组内的资料更新显示窗口。通常与 loadPixels() 一起使用。如果您只需从该数组中读取像素资料，您不需要调用 updatePixels() — 更新只有在进行更改时需要被调用。updatePixels() 应该在像素数组被更改或 set() 被调用时使用，只有使用 set() 或直接修改 pixels[] 的改变会发生。",
      "params": ["数字：欲更新的区域的左上角 x 坐标",
                 "数字：欲更新的区域的左上角 y 坐标",
                 "数字：欲更新的区域的宽度",
                 "数字：欲更新的区域的高度"],
      "returns": ""
    },
    "loadFont": {
      "description": "从一个文件或网址加载一个 opentype 字形文件（.otf、.ttf），将返回一个 p5.Font 物件。这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。<br><br>字形的路径应该相对于链接您的绘图的 HTML 文件。从其他 URL 或远程位置加载字形可能会被浏览器的内建安全模式阻止。",
      "params": ["字符串：该加载的字形名字或网址",
                 "函数：在 loadFont() 完成后该调用的函数",
                 "函数：在发生错误时该调用的函数"],
      "returns": "p5.Font：p5.Font 物件"
    },
    "loadJSON": {
      "description": "从一个文件或网址加载一个 JSON 文件，将返回一个物件。注意如果该 JSON 文件内涵一个数组，此函数仍然会返回一个以数字为指数的物件。<br><br>这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。JSONP 功能支持是由填充工具所提供而您可以使用第二个参数来定义一个有 JSON 回调定义的物件，只需跟从这里的<a href='https://github.com/camsong/fetch-jsonp'>指示</a>。",
      "params": ["字符串：该加载的文件名或网址",
                 "物件：关于 jsonp 设置的设置物件",
                 "字符串：\"json\" 或 \"jsonp\"",
                 "函数：在 loadJSON() 完成后该执行的函数，返回的数据将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": "物件：JSON 数据"
    },
    "loadStrings": {
      "description": "读取一个文件的内容并使用个别字行创造一个字符串数组。如果文件名被用作第一个参数，如以上范例，该文件必须被储存在绘图文件夹内。<br><br>除此之外，该文件也能从本地电脑任何位置加载，只需使用绝对路径（任何在 Unix 及 Linux 内由 / 开始的路径，或在 Windows 内由驱动器符号开始的路径），又或者任何在网络上的文件网址也能用来当作 filename 参数。<br><br>这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。",
      "params": ["字符串：该加载的文件名或网址",
                 "函数：在 loadStrings() 完成后该执行的函数，返回的数组将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": "字符串[]：字符串数组"
    },
    "loadTable": {
      "description": "读取一个文件的内容并使用其内容创造一个 p5.Table 物件。如果文件名被用作第一个参数，该文件必须被储存在绘图文件夹内。文件名参数也能是一个在网络上的文件的网址。默认上，该文件被假定为以逗号分隔（格式为 CSV）。该表格只会在 ‘header’ 设置被使用时才会寻找标签。<br><br>可使用的设置包括：<ul><li>csv - 将表格解析为逗号分隔值</li><li>tsv - 将表格解析为制表符分隔值</li><li>header - 这表格有标签行</li></ul><br><br>当使用多个设置时，您只需将他们分为个别的参数并使用逗号分隔。例如：<br><br><code>loadTable('my_csv_file.csv', 'csv', 'header'); </code><br><br>所有加载及储存的文件都需使用 UTF-8 编码。<br><br>这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。在 preload() 内调用 loadTable() 将保证加载工作会在 setup() 及 draw() 被调用前完成<br><br>在 preload() 外，您可以提供一个回调函数以处理加载物件。",
      "params": ["字符串：该加载的文件名或网址",
                 "字符串：\"header\" \"csv\" \"tsv\"",
                 "函数：在 loadTable() 完成后该执行的函数，返回的 Table 物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": "物件：含有数据的 Table 物件"
    },
    "loadXML": {
      "description": "读取一个文件的内容并使用其内容创造一个 XML 物件。如果文件名被用作第一个参数，该文件必须被储存在绘图文件夹内。<br><br>除此之外，该文件也能从本地电脑任何位置加载，只需使用绝对路径（任何在 Unix 及 Linux 内由 / 开始的路径，或在 Windows 内由驱动器符号开始的路径），又或者任何在网络上的文件网址也能用来当作 filename 参数。<br><br>这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。在 preload() 内调用 loadTable() 将保证加载工作会在 setup() 及 draw() 被调用前完成<br><br>在 preload() 外，您可以提供一个回调函数以处理加载物件。",
      "params": ["字符串：该加载的文件名或网址",
                 "函数：在 loadXML() 完成后该执行的函数，返回的 XML 物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": "物件：含有数据的 XML 物件"
    },
    "loadBytes": {
      "description": "",
      "params": ["字符串：该加载的文件名或网址",
                 "函数：在 load() 完成后该执行的函数",
                 "函数：在发生错误时该执行的函数"],
      "returns": "物件：一个 ‘bytes’ 属性将为被加载的缓冲区的物件"
    },
    "httpGet": {
      "description": "执行 HTTP GET 请求的函数。如果数据类型（datatype）没有被定义的话，p5 将会尝试根据网址猜返回数据的类型，默认为文字。这和调用 httpDo(path, 'GET') 的效果一样。‘binary’ 数据类型将会返回一个 Blob 物件，而 ‘arrayBuffer’ 数据类型将会返回一个 ArrayBuffer 并可用来创造类型化数组（如 Uint8Array）。",
      "params": ["字符串：该加载的文件名或网址",
                 "字符串：\"json\"、\"jsonp\"、\"binary\"、\"arrayBuffer\"、\"xml\"或\"text\"",
                 "物件|布尔值：与请求一起传送的参数资料",
                 "函数：在 httpGet() 完成后该执行的函数，返回的资料物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": ""
    },
    "httpPost": {
      "description": "执行 HTTP POST 请求的函数。如果数据类型（datatype）没有被定义的话，p5 将会尝试根据网址猜返回数据的类型，默认为文字。这和调用 httpDo(path, 'POST') 的效果一样。",
      "params": ["字符串：该加载的文件名或网址",
                 "字符串：\"json\"、\"jsonp\"、\"xml\" 或 \"text\"。如果不提供此参数，httpPost() 将尝试猜",
                 "物件|布尔值：与请求一起传送的参数资料",
                 "函数：在 httpPost() 完成后该执行的函数，返回的资料物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": ""
    },
    "httpDo": {
      "description": "执行 HTTP 请求的函数。如果数据类型（datatype）没有被定义的话，p5 将会尝试根据网址猜返回数据的类型，默认为文字。<br><br>如果需要更高等的使用法，您可以在第一个参数给予路径而第二个参数给予一个物件，物件内容设置与 Fetch API 规范的一样。",
      "params": ["字符串：该加载的文件名或网址",
                 "字符串：\"GET\"、\"POST\" 或 \"PUT\"，默认为 \"GET\"",
                 "字符串：\"json\"、\"jsonp\"、\"xml\" 或 \"text\"",
                 "物件|布尔值：与请求一起传送的参数资料",
                 "函数：在 httpDo() 完成后该执行的函数，返回的资料物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数",
                 "物件：Request 物件，请参考 “fetch” API <a href='https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API'>文献</a>以了解可使用设置"],
      "returns": ""
    },
    "createWriter": {
      "description": "",
      "params": ["字符串：该创造的文件的名",
                 "字符串："]
    },
    "save": {
      "description": "储存一个图像、文字、JSON、csv、wav 或 html 文件。将提示客户电脑下载文件。<b>注意 save() 函数不建议在正在循环执行的 draw 函数内使用，因为每一次被调用 save() 函数将会弹出一个储存对话框。</b><br><br>默认上此函数将储存画布成一个图像。您也可以选择定义一个文件名。例如：<pre>CODE BLOCK PENDING</pre>除此之外，第一个参数也能是个画布 p5.Element 的对象、字符串数组、JSON 数组、JSON 物件、p5.Table、p5.Image 或 p5.SoundFile（需要 p5.sound）。第二个参数为文件名（包括扩展名）。第三个参数适用于特别给这一类物件的设定。这函数将会储存一个符合给予的参数的文件。例如：<pre>CODE BLOCK PENDING</pre>",
      "params": ["物件|字符串：如果所提供的是文件名，此函数将会使用该文件名加上 png 或 jpg 文件扩展名来储存画布为一个图像。如果所提供的是物件，此函数则会一物件所定义的方式储存文件（请参考以上范例）。",
                 "字符串：如果所提供的第一个参数为物件，那第二个参数则定义文件名，同时必须包括适当的文件扩展名（请参考以上范例）。",
                 "布尔值|字符串：依文件类型而定的设定。比如说，在储存 JSON 时，true 表示输出文件将会针对文件大小进行优化，而同时牺牲可读性。"],
      "returns": ""
    },
    "saveJSON": {
      "description": "将一个数组或 JSON 物件的内容写进一个 .json 文件内。文件的储存方式及地点在不同浏览器之间有所不同。",
      "params": ["数组|物件：",
                 "字符串：",
                 "布尔值：如果为 true，将移除输出文件内的换行符及空格以优化文件大小（但牺牲可读性）"],
      "returns": ""
    },
    "saveStrings": {
      "description": "将一个字符串数组写进一个文字文件内，每一行为每一组字符串。文件的储存方式及地点在不同浏览器之间有所不同。",
      "params": ["字符串[]：该输出的字符串数组",
                 "字符串：输出文件的名字",
                 "字符串：文件扩展名"],
      "returns": ""
    },
    "saveTable": {
      "description": "将一个表格（Table）物件的内容写进一个文件内。默认将储存为逗号分隔值（'csv'）的文字文件但也可以使用制表符分隔（'tsv'）或生成一个 HTML 表格（'html'）。文件的储存方式及地点在不同浏览器之间有所不同。",
      "params": ["p5.Table：该储存在文件内的表格物件",
                 "字符串：储存表格文件的名字",
                 "字符串：可以是 \"tsv\"、\"csv\" 或 \"html\""],
      "returns": ""
    },
    "p5.Table": {
      "description": "Los objetos Table almacenan datos con múltiples filas y columnas, tal como una hoja de cálculo tradicional. Los objetos Table pueden ser generados desde cero, dinámicamente, o usando datos desde un archivo existente.",
      "params": ["Arreglo: un arreglo de objetos p5.TableRow"],
      "returns": "p5.Table: 该 p5 物件.Table generado"
    },
    "p5.TableRow": {
      "description": "Un objeto TableRow representa una única fila de datos, grabados en columnas, de una tabla. Un objeto TableRow contiene tanto un arreglo ordenado, como un objeto JSON desordenado.",
      "params": ["String: opcional, puebla la fila con una serie de valores, separados por el separador",
      "String: por defecto, valores separados por coma (csv)"],
      "returns": "该 p5 物件"
    },
    "day": {
      "description": "p5.js 将与您的电脑的时钟沟通，day() 函数将返回当天的日期天数在 1 - 31 的范围内。",
      "returns": "整数：当天的日期天数"
    },
    "hour": {
      "description": "p5.js 将与您的电脑的时钟沟通，hour() 函数将返回当时时间的小时数在 0 - 23 的范围内。",
      "returns": "整数：当时时间的小时数"
    },
    "minute": {
      "description": "p5.js 将与您的电脑的时钟沟通，minute() 函数将返回当时时间的分钟数在 0 - 59 的范围内。",
      "returns": "整数：当时时间的分钟数"
    },
    "millis": {
      "description": "返回自程序开始以来的毫秒（一秒的一千分之一）数。这资料一般可用于定时事件及动画序列。",
      "returns": "整数：自程序开始以来的毫秒数"
    },
    "month": {
      "description": "p5.js 将与您的电脑的时钟沟通，month() 函数将返回当天的日期月数在 1 - 12 的范围内。",
      "returns": "整数：当时日期的月数"
    },
    "second": {
      "description": "p5.js 将与您的电脑的时钟沟通，second() 函数将返回当时时间的秒数在 0 - 59 的范围内。",
      "returns": "整数：当时时间的秒数"
    },
    "year": {
      "description": "p5.js 将与您的电脑的时钟沟通，year() 函数将返回当天的日期年数为一个整数（2014、2015、2016等等）。",
      "returns": "整数：当时日期的年数"
    },
    "p5.XML": {
      "description": "XML es una representación de un objeto XML, capaz de procesar código XML. Usa loadXML() para cargar archivos externos XML y crear objetos XML",
      "params": ["String:"],
      "returns": "p5.XML: 该 p5 物件.XML generado"
    },
    "createVector": {
      "description": "创造一个新的 p5.Vector 向量（用以储存向量的数据类型）。此函数将提供一个二维或三维的向量，准确来说一个欧几里得（也称为几何）向量。向量为一个有大小及方向的量。",
      "params": ["数字：该向量的 x 分量",
                 "数字：该向量的 y 分量",
                 "数字：该向量的 z 分量"],
      "returns": "p5.Vector"
    },
    "p5.Vector": {
      "description": "Una clase para describir un vector de dos o tres dimensiones, específicamente un vector euclideano (también conocido como geométrico). Un vector es una entidad que tiene tanto magnitud como dirección. El tipo de datos, sin embargo, graba los componentes del vector (x, y para 2D y x,y,z para 3D). La magnitud y la dirección pueden ser calculados con los métodos mag() y heading(). En muchos de los ejemplos de p5.js, verás que p5.Vector es usado para describir una posición, velocidad o aceleración. Por ejemplo, si consideras un rectángulo moviéndose a lo largo de la pantalla, en cada instante tiene una posición (un vector que apunta desde el origen hasta su ubicación), una velocidad(la tasa a la que la posición del objeto cambia por unidad de tiempo, expresada como vector), y aceleración (la tasa a la que la velocidad del objeto cambia por unidad de tiempo, expresada como vector). Como los vectores representan grupos de valores, no podemos simplemente usar las operaciones tradicionales de adición, multiplicación, etc. En vez de eso, necesitaremos hacer matemática de vectores, lo que es simplificado con los métodos dentro de la clase p5.Vector.",
      "params": ["Número: componente x del vector",
                 "Número: componente y del vector",
                 "Número: componente z del vector"],
      "returns": "该 p5 物件"
    },
    "abs": {
      "description": "计算一个数字的绝对值（大小值）。映射到 Math.abs()。一个数字的绝对值一定是个正数。",
      "params": ["数字：用于计算的数字"],
      "returns": "数字：被给予数字的绝对值"
    },
    "ceil": {
      "description": "计算最靠近并大于或等于参数值的整数。映射到 Math.ceil()。比如说，ceil(9.03) 将返回 10。",
      "params": ["数字：该取整的数字"],
      "returns": "整数：取整后的数字"
    },
    "constrain": {
      "description": "限制一个数字于最低值与最高值之间。",
      "params": ["数字：该限制的数字",
                 "数字：最低值",
                 "数字：最高值"],
      "returns": "数字：被限制后的数字"
    },
    "dist": {
      "description": "计算两点之间的距离。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第一个点的 z 坐标",
                 "数字：第二个点的 z 坐标"],
      "returns": "数字：两点之间的距离"
    },
    "exp": {
      "description": "返回欧拉数 e （2.71828...）提升到由参数 n 定义的指数。映射到 Math.exp()。",
      "params": ["数字：该提升的指数"],
      "returns": "数字：e^n"
    },
    "floor": {
      "description": "计算最靠近并小于或等于参数值的整数。映射到 Math.floor()。",
      "params": ["数字：该取整的数字"],
      "returns": "整数：取整后的数字"
    },
    "lerp": {
      "description": "计算一个介于两个数字之间所定义的插值量位置的数字。amt 参数为两个值之间的插值量，0.0 为第一个值，0.1 为非常接近第一个值，0.5 为两者之间等等。lerp 函数可用来沿着直线制作动画及绘制虚线。",
      "params": ["数字：第一个值",
                 "数字：第二个值",
                 "数字：介于 0.0 与 1.0 之间的数字"],
      "returns": "数字：插值"
    },
    "log": {
      "description": "计算一个数字的自然对数（e 为底数的对数）。这函数需要 n 参数大于 0.0。映射到 Math.log()。",
      "params": ["数字：大于 0 的数字"],
      "returns": "数字：n 的自然对数"
    },
    "mag": {
      "description": "计算一个向量的大小（或长度）。向量为一个空间内的方向，通常用于电脑图形及线性代数。因为它没有“开始”位置，一个向量的大小可以被想成是 0,0 坐标与向量 x,y 坐标之间的距离。因此，mag() 是 dist(0, 0, x, y) 的缩写。",
      "params": ["数字：第一个值",
                 "数字：第二个值"],
      "returns": "数字：从 (0, 0) 至 (a, b) 的向量的大小"
    },
    "map": {
      "description": "从一个范围内映射一个数字去另一个范围。<br><br>在以上第一个范例，25 被从 0 至 100 之间的范围映射去窗口最左方 (0) 至最右方 (width) 的范围内。",
      "params": ["数字：该转换的值",
                 "数字：现在值的最低值",
                 "数字：现在值的最低值",
                 "数字：目标值的最低值",
                 "数字：目标值的最高值",
                 "布尔值：限制目标值在最高及最低值之间"],
      "returns": "数字：映射后的数字"
    },
    "max": {
      "description": "找出一系列数字中最大的值，并返回该值。max() 能接受任何数量的数字参数，或是一个任何大小的数组。",
      "params": ["数字：用于比较的数字",
                 "数字：用于比较的数字",
                 "数字[]：用于比较的数字"],
      "returns": "数字：最高值的数字"
    },
    "min": {
      "description": "找出一系列数字中最小的值，并返回该值。min() 能接受任何数量的数字参数，或是一个任何大小的数组。",
      "params": ["数字：用于比较的数字",
                 "数字：用于比较的数字",
                 "数字[]：用于比较的数字"],
      "returns": "数字：最低值的数字"
    },
    "norm": {
      "description": "将一个数字由一个范围标准化成介于 0 及 1 之间的值。与 map(value, low, high, 0, 1) 的效果相同。在范围外的数字将不会被限制在 0 与 1 之间，因为范围外的值通常是有意及有用的。（参考以上第二个范例）",
      "params": ["数字：该标准化的值",
                 "数字：现在值的最低值",
                 "数字：现在值的最高值"],
      "returns": "数字：标准化后的数字"
    },
    "pow": {
      "description": "执行幂运算。pow() 函数是个能有效率地将数字大量乘于自己（或其倒数）的方式。比如说，pow(3, 5) 等同于 3*3*3*3*3 而 pow(3, -5) 等同于 1 / (3*3*3*3*3)。映射到 Math.pow()。",
      "params": ["数字：幂运算的底数",
                 "数字：幂运算的指数"],
      "returns": "数字：n^e"
    },
    "round": {
      "description": "计算最靠近 n 参数的整数。比如说，round(133.8) 将返回 134。映射到 Math.round()。",
      "params": ["数字：该取整的数字"],
      "returns": "整数：取整后的数字"
    },
    "sq": {
      "description": "平方一个数字（将数字乘于自己）。结果一定是个正数，因为将两个负数相乘一定会有一个正数结果。比如说 -1 * -1 = 1。",
      "params": ["数字：该平方的数字"],
      "returns": "数字：平方后的数字"
    },
    "sqrt": {
      "description": "计算一个数字的平方根。一个数字的平方根一定是个正数，虽然也可能有正确的负数平方根。一个数字 a 的平方根 s 有以下属性 s*s = a。此函数为取平方的相反。映射到 Math.sqrt()。",
      "params": ["数字：该取平方根的非负数"],
      "returns": "数字：取平方根后的数字"
    },
    "noise": {
      "description": "返回所定义坐标的柏林噪声值。柏林噪声是个用来生成比 random() 所能生成更自然及更谐波的随机数字系列。在 1980 年代有 Ken Perlin 所发明，柏林噪声至今常被用在图形应用程序中生成程序纹理、自然运动、形状、地形等等。<br><br>柏林噪声与 random() 函数最主要的不同点在于前者是在一个无限的 n 维空间内定义的，这空间内每一对坐标都相对于一个固定的半随机值（只有在程序进行时为固定的；请参考 noiseSeed() 函数）。p5.js 能计算 1 维、2 维及 3 维噪声，这取决于所给予的坐标数。返回的值一定会在 0.0 至 1.0 之间。噪音值可以通过在噪音空间内移动以制成动画，如以上范例所示。第二及第三个空间维度也能被解读成时间。<br><br>所生成的噪音结构上和一般音频信号相似，尤其是此函数的频率。与物理学上谐波的概念相似，泊林噪音也是在计算几个八度后再将其结果加起来以得到最后的结果。<br><br>另外一个控制返回随机数系列的特征的方法是控制输入坐标值的大小。因为此函数能在无限之的空内内应用，输入坐标的值并不重要，只有个别坐标之间的距离需要被注意（如在循环内使用 noise() 时）。一般来说坐标之间的距离越小，生成噪声随机数列将会越平滑。介于 0.005-0.03 之间的距离应该适合大多数应用场合，不过这可能因应用需求而变。",
      "params": ["数字：噪声空间的 x 坐标",
                 "数字：噪声空间的 y 坐标",
                 "数字：噪声空间的 z 坐标"],
      "returns": "数字：柏林噪声在特定坐标的值（介于 0 与 1 之间）"
    },
    "noiseDetail": {
      "description": "调整柏林噪声函数所生成的噪声特征及细节度。与物理学上谐波的概念相似，泊林噪音也是在计算几个八度后才得到最后的结果。越低的八度将会影响输出信号值越多因此同时会定义噪音的整体强度，而较高的八度将会在噪音系列中制作更精细的细节。<br><br>默认上，此噪音将使用四个八度计算而每个八度将有其前者一半的影响力，第一个八度的影响力为 50% 。这衰退值能通过加多一个参数而改变。比如说如果衰退因数为 0.75 那表示每个八度将会有其前者的 75% 的影响力（减少 25%）。任何介于 0.0 与 1.0 的值都能被接受，不过注意高于 0.5 的值可能会造成 noise() 函数会返回大于 1.0 的值。<br><br>通过改变这些参数，noise() 函数所生成的信号可适应于非常特别的需求或特点。",
      "params": ["数字：噪音该使用的八度数",
                 "数字：每个八度的衰退因数"],
      "returns": ""
    },
    "noiseSeed": {
      "description": "定义 noise() 使用的随机种子值。默认上，noise() 将在每一次改程序被执行时生成不同的结果。只需定义 value 参数至一个常量就能确保每一次软件执行时都会返回一样的随机数列。",
      "params": ["数字：随机种子值"],
      "returns": ""
    },
    "acos": {
      "description": "cos() 的反值，将返回一个值的反余弦值。此函数接受介于 -1 与 1 之间的值并将返回介于 0 与 PI（3.1415927）之间的值。",
      "params": ["数字：该取反余弦值的值"],
      "returns": "数字：该值的反余弦值"
    },
    "asin": {
      "description": "sin() 的反值，将返回一个值的反正弦值。此函数接受介于 -1 与 1 之间的值并将返回介于 -PI/2 与 PI/2 之间的值。",
      "params": ["数字：该取反正弦值的值"],
      "returns": "数字：该值的反正弦值"
    },
    "atan": {
      "description": "tan() 的反值，将返回一个值的反正切值。此函数接受介于 -Infinity 与 Infinity（包括 Infinity）之间的值并将返回介于 -PI/2 与 PI/2 之间的值。",
      "params": ["数字：该取反正切值的值"],
      "returns": "数字：该值的反正切值"
    },
    "atan2": {
      "description": "计算从一个被定义的点到坐标原点的弧度，并由正 x 轴开始计算。将返回介于 PI 与 -PI 之间的浮点数。atan2() 函数通常用于定向几何图形至鼠标的位置。<br><br>注意：第一个参数为 y 坐标，而第二个参数为 x 坐标，这是为了适应计算正切值的结构。",
      "params": ["数字：该点的 y 坐标",
                 "数字：该点的 x 坐标"],
      "returns": "数字：该点的反正切值"
    },
    "cos": {
      "description": "计算一个角度的余弦值。此函数将使用当时的角度模式。返回值将介于 -1 与 1 之间的值。",
      "params": ["数字：角度"],
      "returns": "数字：该角度的余弦值"
    },
    "sin": {
      "description": "计算一个角度的正弦值。此函数将使用当时的角度模式。返回值将介于 -1 与 1 之间的值。",
      "params": ["数字：角度"],
      "returns": "数字：该角度的正弦值"
    },
    "tan": {
      "description": "计算一个角度的正切值。此函数将使用当时的角度模式。返回值将介于 -1 与 1 之间的值。",
      "params": ["数字：角度"],
      "returns": "数字：该角度的正切值"
    },
    "degrees": {
      "description": "将一个弧度值转换成其相对的角度值。弧度和角度为两个测量同样一个东西的方法。一个圆形里有 360 度而也有 2*PI 个弧度。比如说，90° = PI/2 = 1.5707964。此函数将不会使用当时的角度模式。",
      "params": ["数字：由弧度转换成角度的值"],
      "returns": "数字：转换后的角度值"
    },
    "radians": {
      "description": "将一个角度值转换成其相对的弧度值。弧度和角度为两个测量同样一个东西的方法。一个圆形里有 360 度而也有 2*PI 个弧度。比如说，90° = PI/2 = 1.5707964。此函数将不会使用当时的角度模式。",
      "params": ["数字：由角度转换成弧度的值"],
      "returns": "数字：转换后的角度值"
    },
    "angleMode": {
      "description": "定义当时 p5 的角度模式。默认模式为 RADIANS（弧度）。",
      "params": ["常量：RADIANS 或 DEGREES"],
      "returns": ""
    },
    "randomSeed": {
      "description": "定义 random() 使用的随机种子值。<br><br>默认上，random() 将在每一次改程序被执行时生成不同的结果。只需定义 seed 参数至一个常量就能确保每一次软件执行时都会返回一样的伪随机数。",
      "params": ["数字：随机种子值"],
      "returns": ""
    },
    "random": {
      "description": "返回一个随机的浮点数。<br><br>可使用 0、1 或 2 个参数。<br><br>如果并没有定义任何参数，将返回一个介于 0 与 1（但不包括 1）的随机数。<br><br>如果只定义一个参数并且该参数为数字，将返回一个介于 0 与 该数字（但不包括该数字）的随机数。<br><br>如果值定义一个参数并且该参数为数组，将返回该数组中随机一个元素。<br><br>如果定义两个参数，将返回一个介于第一个参数与第二个参数（但不包括第二个参数）的随机数。",
      "params": ["数字：最低值（包括此值）",
                 "数字：最高值（不包括此值）",
                 "数组：供选择的数组"],
      "returns": "数字：随机数"
    },
    "randomGaussian": {
      "description": "返回一个符合高斯，或正态，分布的随机数。理论上 randomGaussian() 没有最高或最低返回值。不过，差均值很多的值被返回的机率将会很低；而接近均质的值被返回的机率将会相对较高。<br><br>可使用 0、1 或 2 个参数。<br>如果并没有定义任何参数，将使用均值为 0 与 标准差为 1。<br>如果只定义一个参数，该参数将为均值（标准差为 1）。<br>如果定义两个参数，第一个参数为均值，第二个参数为标准差。",
      "params": ["数字：均值",
                 "数字：标准偏差"],
      "returns": "数字：随机数"
    },
    "textAlign": {
      "description": "定义绘制问题的对齐方向。使用两个参数：horizAlign（LEFT、CENTER 或 RIGHT）及 vertAlign（TOP、BOTTOM、CENTER 或 BASELINE）。<br><br>horizAlign 参数为 text() 函数的 x 值，而 vertAlign 参数为 y 值。<br><br>因此如果您使用 textAlign(LEFT)，您将会使文字最左方对齐 text() 函数所使用的 x 参数。如果您使用 textAlign(RIGHT, TOP)，您将会使文字最右方对齐 x 值而文字最上方对齐 y 值。",
      "params": ["常量：水平对齐，LEFT、CENTER 或 RIGHT",
                 "常量：垂直对齐，TOP、BOTTOM、CENTER 或 BASELINE"],
      "returns": ""
    },
    "textLeading": {
      "description": "定义或获取行与行之间的像素距离。此设置将会在所有接下来的 text() 函数调用时生效。",
      "params": ["数字：行与行之间的像素距离"],
      "returns": ""
    },
    "textSize": {
      "description": "定义或获取当时的字体大小。这大小将会在所有接下来的 text() 函数调用时生效。字形大小是使用像素定义。",
      "params": ["数字：字体的像素大小"],
      "returns": ""
    },
    "textStyle": {
      "description": "定义或获取系统字体的风格，可以是 NORMAL、ITALIC 或 BOLD。注意：这可能被 CSS 风格所覆盖。至与非系统字体（opentype、truetype 等）请直接加载已风格化的字体。",
      "params": ["常量：字体的风格，可以是 NORMAL、ITALIC 或 BOLD"],
      "returns": ""
    },
    "textWidth": {
      "description": "计算及返回任何字符或字符串的宽度。",
      "params": ["字符串：该测量的字符串"],
      "returns": "数字"
    },
    "textAscent": {
      "description": "返回当时字体在当时所定的大小的整体高度。这高度代表从基准线算起至最高字体的顶点的距离。",
      "returns": "数字"
    },
    "textDescent": {
      "description": "返回当时字体在当时所定的大小的下端线高度。",
      "returns": "数字"
    },
    "text": {
      "description": "将文字绘制在荧幕上。显示第一个参数内的资料在荧幕上由其他参数所定义的位置。将会使用默认字形除非使用 textFont() 函数定义使用其他字形同时也将使用默认大小除非使用 textSize() 定义文字大小。文字的颜色可使用 fill() 函数定义。可使用 stroke() 及 strokeWeight() 函数添加文字外形线。<br><br>文字显示将位于 textAlign() 函数所定义的位置，您可将文字绘制在坐标的左边、右边或中间。<br><br>x2 及 y2 参数将定义一个方形文字显示区而且只适用于字符串资料类型。当这两个参数被定义时，它们将使用当时的 rectMode() 设置被解读。不符合方形大小的文字将不会被绘制在荧幕上。",
      "params": ["字符串|物件|数组|数字|布尔值：该显示的字母数字符号",
                 "数字：文字的 x 坐标",
                 "数字：文字的 y 坐标",
                 "数字：默认上，文字格的宽度，请参考 rectMode()",
                 "数字：默认上，文字格的高度，请参考 rectMode()"],
      "returns": ""
    },
    "textFont": {
      "description": "定义使用 text() 函数绘制文字时该使用的字形。",
      "params": ["物件|字符串：一个使用 loadFont() 加载的字形，或一个代表 Web 安全字体（一个所有系统都通用的字形）的字符串",
                 "数字：字形大小"],
      "returns": ""
    },
    "p5.Font": {
      "description": "Clase base para manipulación de tipografía",
      "params": ["物件：puntero a la instancia p5"],
      "returns": "该 p5 物件"
    },
    "append": {
      "description": "Añade un valor al final de un arreglo. Extiende el largo de un arreglo en una unidad. Usa la función Array.push()",
      "params": ["Arreglo: Arreglo al que se agregará el dato",
                 "Cualquiera: a ser añadido al arreglo"],
      "returns": "该 p5 物件"
    },
    "arrayCopy": {
      "description": "Copia el arreglo (o una parte del arreglo) a otro arreglo. El arreglo fuente es copiado al arreglo de destino, empezando por la posición especificada por srcPosition y a la posición especificada por dstPosition. El número de elementos a copiar es determinado por el largo. Notar que al copiar valores se sobreescriben los valores existentes en el arreglo de destino. Para anexar valores en vez de sobreescribirlos, usa la función concat(). La versión simplificada con dos argumentos, arrayCopy(src, dest), copia un arreglo entero a otro del mismo tamaño. Es equivaletne a arrayCopy(src, 0, dst, 0, src.length). Usar esta función es mucho más eficiente para copiar datos de un arreglo que iterar con un bucle for() y copiar cada elemento individualmente. ",
      "params": ["Arreglo: el arreglo fuente",
                 "Número: posición inicial en el arreglo fuente",
                 "Arreglo: el arreglo de destino",
                 "Número: posición inicial del arreglo de destino",
                 "Número: númeor de elementos del arreglo a ser copiados"],
      "returns": "该 p5 物件"
    },
    "concat": {
      "description": "Concatena dos arreglos, usa la función Array.concat(). No modifica los arreglos de entrada.",
      "params": ["Arreglo: primer arreglo a concatenar",
                 "Arreglo: segundo arreglo a concatenar"],
      "returns": "Arreglo: el arreglo concatenado"
    },
    "reverse": {
      "description": "Invierte el orden un arreglo, usa Array.reverse().",
      "params": ["Arreglo: arreglo a ser invertido"],
      "returns": "该 p5 物件"
    },
    "shorten": {
      "description": "Disminuye un arreglo en un elemento y retorna el arreglo más corto, usa Array.pop().",
      "params": ["Lista: arreglo a acortar"],
      "returns": "Arreglo: el arreglo acortado"
    },
    "shuffle": {
      "description": "Ordena aleatoriamente los elementos de un arreglo. Implementa el algoritmo Fisher Yates.",
      "params": ["Arreglo: Arreglo a ordenar",
                 "Boolean: modifica el arreglo"],
      "returns": "Arreglo: retorna el arreglo ordenado"
    },
    "sort": {
      "description": "Ordena un arreglo de números, desde el más pequeño al más grande, o pone un arreglo de palabras en orden alfabético. El arreglo original no es modificado, un nuevo arreglo ordenado es retornado. El parámetro count define el número de elementos a ordenar. Por ejemplo, si hay 12 elementos en un arreglo y count es 5, los primeros 5 elementos del arreglo serán ordenados.",
      "params": ["Arreglo: arreglo a ordenar",
                 "Número: número de elementos a ordenar, empezando desde 0"],
      "returns": "该 p5 物件"
    },
    "splice": {
      "description": "Inserta un valor o un arreglo de valores en un arreglo existente El primer parámetro especifica el arreglo inicial a ser modificado, y el segundo parámetro define los datos a insertarse. El tercer parámetro es un índice que especifica la posición del arreglo a partir de la que se insertarán los datos. Recuerda que el índice del arreglo empieza en 0, así que la primera posición es 0, la segunda es 1, etc.",
      "params": ["Arreglo: arreglo a ser modificado",
                 "Cualquiera: valor a ser introducido",
                 "Número: posición del arreglo donde se inserta el dato"],
      "returns": "该 p5 物件"
    },
    "subset": {
      "description": "Extrae un arreglo de elementos de un arreglo existente. El parámetro list define el arreglo desde el cual los elementos serán copiados, y los parámetros start y count especifican cuáles elementos extraer. Si no especifica count, los elementos serán extraidos desde el principio. Esta función no modifica el arreglo original",
      "params": ["Arreglo: arreglo del cual se extrae",
                 "Número: posición de donde empezar a extraer",
      "          Número: número de valores a extraer"],
      "returns": "Arreglo: arreglo de elementos extraidos"
    },
    "float": {
      "description": "Convierte un String a su representación de punto flotante. Los contenidos de un String deben parecerse a un número, en otro caso NaN es retornado. Por ejemplo, float('1234.56') evalua a 1234.56, pero float('giraffe') retorna NaN. Cuando un arreglo de valores es pasado, un arreglo de floats del mismo largo es retornado.",
      "params": ["String: string a ser procesado"],
      "returns": "Número: representación en punto flotante de un string"
    },
    "int": {
      "description": "Convierte un boolean, string o float a su representación en número entero. Cuando un arreglo de valores es introducido, entonces un arreglo de enteros de la misma longitud es retornado.",
      "params": ["String|Boolean|Número|Arreglo: valor a procesar"],
      "returns": "Número: valor representado como entero"
    },
    "str": {
      "description": "Convierte un boolean, string, o número a su representación en string. Cuando un arreglo de valores es introducido, entonces un arreglo de strings de la misma longitud es retornado.",
      "params": ["String|Boolean|Número|Arreglo: valor a procesar"],
      "returns": "String: valor representado como string"
    },
    "boolean": {
      "description": "Convierte un número o string a su representación en boolean. Para números, cualquier valor distinto de cero (positivo o ne gativo), evalua a true, mientras que cero evalua a falso. Para un string, el valor true evalua a true, mientras que cualquier otro valor evalua a falso. Cuando un arreglo de números o strings es introducido, entonces un arreglo de booleans de la misma longitud es retornado.",
      "params": ["String|Boolean|Número|Arreglo: valor a procesar"],
      "returns": "Boolean: representación en formato boolean del valor"
    },
    "byte": {
      "description": "Convierte un número, string o boolean a su representación en byte. Un byte puede solo ser un número entero entre -128 y 127, así que cuando un valor fuera de este rango es convertido, se hace wrap a la representación correspondiente en byte. Cuando un arreglo de números, string, o booleans es introducido, entonces un arreglo de bytes de la misma longitud es retornado.",
      "params": ["String|Boolean|Número|Arreglo: valor a procesar"],
      "returns": "Número: representación en formato byte del valor"
    },
    "char": {
      "description": "Convierte un número o string a su representaciómo como un string de un único caracter. Si se provee un parámetro, es primero pasado como entero y luego evaluado como un string de un único caracter. Cuando un arreglo de números o strings es introducido, entonces un arreglo de strings de un único caracter de la misma longitud es retornado.",
      "params": ["String|Número|Arreglo: valor a procesar"],
      "returns": "String: representación en formato string del valor"
    },
    "unchar": {
      "description": "Convierte un string de un único caracter a su correspondiente representación como valor entero. Cuando un arreglo de strings de un caracter es introducido, entonces un arreglo de enteros de la misma longitud es retornado.",
      "params": ["String|Arreglo: valor a procesar"],
      "returns": "Número: representación en formato entero del valor"
    },
    "hex": {
      "description": "Convierte un número a su correspondiente representación como hexadecimal. Si se ingersa un segundo parámetro, es usado para definir el número de caracteres a generar en la notación hexadecimal. Cuando un arreglo es introducido, entonces un arreglo de strings en notación hexadecimal de la misma longitud es retornado.",
      "params": ["Número|Arreglo: valor a procesar"],
      "returns": "String: representación en formato string hexadecimal del valor"
    },
    "unhex": {
      "description": "Convierte una representación en string de un número hexadecimal a su correspondiente representación como valor entero. Cuando un arreglo de strings en notación hexadecimal es introducido, entonces un arreglo de enteros de la misma longitud es retornado.",
      "params": ["String|Arreglo: valor a procesar"],
      "returns": "Número: representación en formato entero del valor hexadecimal"
    },
    "join": {
      "description": "Combina una arreglo de Strings en un String, cada uno separado por los caracteres usados como parámetro separator. Para unir arreglos de enteros o floats, es necesario primero convertirlos a Strings usando las funciones nf() o nfs().",
      "params": ["Arreglo: arreglo de Strings a ser unidos",
                 "String: String a ser posicionado entre cada item"],
      "returns": "String: String unificado"
    },
    "match": {
      "description": "Esta función es usada para aplicar una expresión regular a una porción de texto,  y retorna grupos coincidentes (elementos encontrados entre paréntesis) como un arreglo de Strings. Si no existen coincidencias, se retorna el valor null. Si no se especifican grupos en la expresión regular, pero la secuencia coincide, un arreglo de largo 1 (con el texto coincidente como primer elemento del arreglo) será retornado. Para usar la función, primero comprueba si el resultado es null. Si el resultado es null, entonces la secuencia no tuvo coincidencias. Si la secuencia tuvo coincidencias, retorna un arreglo. Si exsiten grupos (especificados como conjuntos de paréntesis) en la expresión regular, entonces los contenidos de cada uno serán retornados en el arreglo. El elemento[0] de una coincidencia de expresión regular retorna el string coincidente, y el grupo de coincidencia empieza en el elemento[1] (el primer grupo es [1], el segundo es [2], etc).",
      "params": ["String: el String a ser buscado",
                 "String: la expresión regular a ser usada para buscar coincidencias"],
      "returns": "Arreglo: arreglo de Strings encontrados"
    },
    "matchAll": {
      "description": "Esta función es usada para aplicar una expresión regular a una porción de texto,  y retorna una lista de grupos coincidentes (elementos encontrados entre paréntesis) como un arreglo de Strings bidimensional. Si no existen coincidencias, se retorna el valor null. Si no se especifican grupos en la expresión regular, pero la secuencia coincide, un arreglo de dos dimensiones es retornado, pero es de largo 1. Para usar la función, primero comprueba si el resultado es null. Si el resultado es null, entonces la secuencia no tuvo coincidencias. Si la secuencia tuvo coincidencias, retorna un arreglo 2D. Si exsiten grupos (especificados como conjuntos de paréntesis) en la expresión regular, entonces los contenidos de cada uno serán retornados en el arreglo. El elemento[i][0] de una coincidencia de expresión regular retorna el string coincidente completo, y el grupo de coincidencia empieza en el elemento[i][1] (el primer grupo es [i][1], el segundo es [i][2], etc).",
      "params": ["String: el String a ser buscado",
                 "String: la expresión regular a ser usada para buscar coincidencias"],
      "returns": "Arreglo: arreglo 2D de Strings encontrados"
    },
    "nf": {
      "description": "Función de utilidad para formatear números a strings. Existen dos veriones: una para formatear floats, y una para formatear enteros. Los valores de los dígitos y los parámetros left y right siempre deben ser enteros positivos",
      "params": ["Número|Arreglo: el número a formatear",
                 "Número: número de dígitos a la izquierda del punto decimal",
                 "Número: número de dígitos a la derecha del punto decimal"],
      "returns": "String|Arreglo: String formateada"
    },
    "nfc": {
      "description": "Función de utilidad para formatear números en strings y poner las comas apropiadas para señalar múltiplos de mil. Hay dos versiones: una para números enteros y otra para arreglos de enteros. El valor del parámetro right debe siempre ser un entero positivo.",
      "params": ["Número|Arreglo: el número a formatear",
                 "Número: número de dígitos a la derecha del punto decimal"],
      "returns": "String|Arreglo: String formateada"
    },
    "nfp": {
      "description": "Función de utilidad para formatear números en strings. Similar a nf() pero pone un signo + en frente de los números positivos y un signo - en frente de números negativos. Hay dos versiones, una para formatear floats y otra para formatear enteros. Los valores de los parámetros left y right deben siempre ser enteros positivos.",
      "params": ["Número|Arreglo: el número a formatear",
                 "Número: número de dígitos a la izquierda del punto decimal",
                 "Número: número de dígitos a la derecha del punto decimal"],
      "returns": "String|Arreglo: String formateada"
    },
    "nfs": {
      "description": "Función de utilidad para formatear números en strings. Similar a nf() pero pone un espacio en frente de los números positivos y un signo - en frente de números negativos. Hay dos versiones, una para formatear floats y otra para formatear enteros. Los valores de los parámetros left y right deben siempre ser enteros positivos.",
      "params": ["Número|Arreglo: el número a formatear",
                 "Número: número de dígitos a la izquierda del punto decimal",
                 "Número: número de dígitos a la derecha del punto decimal"],
      "returns": "String|Arreglo: String formateada"
    },
    "split": {
      "description": "La función split usa String.split(), corta un String en pedazos usando un caracter o String como delimitador. El parámetro delim especifica el caracter o caracteres que marcan los bordes entre cada pieza. Un arreglo String[] es retornado, que contiene cada una de las piezas. La función splitTokens() funciona de forma similar, excepto que divide usango un rango de caracteres en vez de usar un caracter o una secuencia de caracteres específicos.",
      "params": ["String: el String a ser dividido",
                 "String: el String usado para separar los datos"],
      "returns": "Arreglo: arreglo de Strings"
    },
    "splitTokens": {
      "description": "La función splitTokens() divide un String en uno o varios caracteres delimitadores o tokens. El parámetro delim especifica el o los caracteres a ser usados como borde. Si no se especifican caracteres delim, cualquier caracter tipo whitespace será usado para dividir. Los caracteres whitespace incluyen tabulación (\t), nueva línea (\n), retorno de carro (\r), entrada de formulario (\f), y espacio.",
      "params": ["String: el String a ser dividido",
                 "String: lista de Strings individuales que serán usados como separadores"],
      "returns": "Arreglo: arreglo de Strings"
    },
    "trim": {
      "description": "Remueve caracteres tipo whitespace (espacio en blanco) del comienzo y el final de un String. En adición a los caracteres estámdar de whitespace como espacio, retorno de carro y tabulación, esta función también remueve el caracter Unicode nbsp.",
      "params": ["String|Arreglo: un String o arreglo de Strings a ser recortados."],
      "returns": "String|Arreglo: un String o arreglo de Strings recortados."
    },
    "camera": {
      "description": "Define la posición de la cámara",
      "params": ["Número: valor de la posición de la cámara en el eje x",
      "Número: valor de la posición de la cámara en el eje y",
      "Número: valor de la posición de la cámara en el eje z"],
      "returns": "p5: 该 p5 物件"
    },
    "perspective": {
      "description": "Define la perspectiva de la cámara",
      "params": ["Número: frustum del campo de visión vertical de la cámara, de abajo hacia arriba, en grados",
      "Número: frustum de la relación de aspecto de la cámara",
      "Número: frustum del largo del plano cercano",
      "Número: frustum del largo del plano lejano"],
      "returns": "p5: 该 p5 物件"
    },
    "ortho": {
      "description": "Define la cámara ortogonal",
      "params": ["Número: define el frustum del plano izquierdo de la cámara",
      "Número: define el frustum del plano derecho de la cámara",
      "Número: define el frustum del plano inferior de la cámara",
      "Número: define el frustum del plano superior de la cámara",
      "Número: define el frustum del plano cercano de la cámara",
      "Número: define el frustum del plano lejano de la cámara"],
      "returns": "p5: 该 p5 物件"
    },
    "ambientLight": {
      "description": "Crea una luz ambiente con color",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color actual), o arreglo de color o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad"],
      "returns": "该 p5 物件"
    },

    "directionalLight": {
      "description": "Crea una luz direccional con color y dirección",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color actual), o arreglo de color o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad",
      "Número|p5.Vector: dirección del eje x o un p5.Vector",
      "Número: opcional, dirección del eje y",
      "Número: opcional, dirección del eje z"],
      "returns": "该 p5 物件"
    },
    "pointLight": {
      "description": "Crea una luz puntual con color y posición",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color actual), o arreglo de color o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad",
      "Número|p5.Vector: dirección del eje x o un p5.Vector",
      "Número: opcional, dirección del eje y",
      "Número: opcional, dirección del eje z"],
      "returns": "p5: 该 p5 物件"
    },
    "normalMaterial": {
      "description": "Material normal para geometría. Puedes ver todos los posibles materiales en este ejemplo (TODO).",
      "returns": "p5: 该 p5 物件"
    },
    "texture": {
      "description": "Textura para geometría. Puedes ver todos los posibles materiales en este ejemplo (TODO).",
      "params": ["p5.Image|p5.MediaElement|p5.Graphics: gráfica bidimensional para hacer render como textura."],
      "returns": "p5: 该 p5 物件"
    },
    "ambientMaterial": {
      "description": "Material ambiente para geometría con un color dado. Puedes ver todos los posibles materiales en este ejemplo (TODO).",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color), o arreglo de color, o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad"],
      "returns": "p5: 该 p5 物件"
    },
    "specularMaterial": {
      "description": "Material espejo para geometría con un color dado. Puedes ver todos los posibles materiales en este ejemplo (TODO).",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo o tinte (dependiendo del modo de color), o arreglo de color, o String de color CSS",
      "Número: opcional, valor de verde o saturación",
      "Número: opcional, valor de azul o brillo",
      "Número: opcional, valor de opacidad"],
      "returns": "p5: 该 p5 物件"
    },
    "p5.RendererGL": {
      "description": "TODO",
      "returns": "p5: 该 p5 物件"
    },
    "p5.Shader": {
      "description": "Clase Shader para el modo WEBGL",
      "params": ["p5.RendererGL: una instancia de p5.RendererGL que servirá de contexto GL para este nuevo p5.Shader",
      "String: código fuente para el vertex shader (en forma de string)",
      "String: código fuente para el fragment shader (en forma de string)"],
      "methods": ["Wrapper de las funciones gl.uniform. Como almacenamos información de uniform en el shader, la podemos usar para revisar los datos provistos y llamar a la función apropiada."]
    }
  },
  "p5.Image": {
    "loadPixels": {
      "description": "blah",
      "params": ["Numero: blah",
                 "Numero: blah"],
      "returns": "TODO"
    }
  },
  "p5.Element": {
    "description": "Clase base para todos los elementos añadidos al bosuqejo, incluyendo lienzo, buffers de gráficas, y otros elementos HTML. Los métodos en azul están incluidos en la funcionalidad base, los métodos en marrón son añadidos con la biblioteca p5.dom. No se ejecutan directamente, pero los objetos p5.Element son creados llamando a las funciones createCanvas(), createGraphics(), o en la biblioteca p5.dom, createDiv, createImg, createInput, etc.",
    "params": ["String: node DOM envolvente.", "物件：puntero a instancia p5."],
    "returns": "TODO"
  }
}
